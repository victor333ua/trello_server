"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@yarnpkg/core");
const core_2 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const plugin_essentials_1 = require("@yarnpkg/plugin-essentials");
const semver_1 = tslib_1.__importDefault(require("semver"));
const typescriptUtils_1 = require("./typescriptUtils");
const getTypesName = (descriptor) => {
    return descriptor.scope
        ? `${descriptor.scope}__${descriptor.name}`
        : `${descriptor.name}`;
};
const afterWorkspaceDependencyAddition = async (workspace, dependencyTarget, descriptor, strategies) => {
    var _a;
    if (descriptor.scope === `types`)
        return;
    const { project } = workspace;
    const { configuration } = project;
    const tsEnableAutoTypes = (_a = configuration.get(`tsEnableAutoTypes`)) !== null && _a !== void 0 ? _a : fslib_1.xfs.existsSync(fslib_1.ppath.join(project.cwd, `tsconfig.json`));
    if (!tsEnableAutoTypes)
        return;
    const resolver = configuration.makeResolver();
    const resolveOptions = {
        project,
        resolver,
        report: new core_2.ThrowReport(),
    };
    const requiresInstallTypes = await (0, typescriptUtils_1.hasDefinitelyTyped)(descriptor, configuration);
    if (!requiresInstallTypes)
        return;
    const typesName = getTypesName(descriptor);
    let range = core_2.structUtils.parseRange(descriptor.range).selector;
    // If the range is a tag, we have to resolve it into a semver version
    if (!core_2.semverUtils.validRange(range)) {
        const normalizedDescriptor = configuration.normalizeDependency(descriptor);
        const originalCandidates = await resolver.getCandidates(normalizedDescriptor, {}, resolveOptions);
        range = core_2.structUtils.parseRange(originalCandidates[0].reference).selector;
    }
    const semverRange = semver_1.default.coerce(range);
    if (semverRange === null)
        return;
    const coercedRange = `${plugin_essentials_1.suggestUtils.Modifier.CARET}${semverRange.major}`;
    const atTypesDescriptor = core_2.structUtils.makeDescriptor(core_2.structUtils.makeIdent(`types`, typesName), coercedRange);
    const projectSuggestions = core_2.miscUtils.mapAndFind(project.workspaces, workspace => {
        var _a, _b;
        const regularDependencyHash = (_a = workspace.manifest.dependencies.get(descriptor.identHash)) === null || _a === void 0 ? void 0 : _a.descriptorHash;
        const devDependencyHash = (_b = workspace.manifest.devDependencies.get(descriptor.identHash)) === null || _b === void 0 ? void 0 : _b.descriptorHash;
        // We only want workspaces that depend the exact same range as the original package
        if (regularDependencyHash !== descriptor.descriptorHash && devDependencyHash !== descriptor.descriptorHash)
            return core_2.miscUtils.mapAndFind.skip;
        const atTypesDependencies = [];
        for (const type of core_1.Manifest.allDependencies) {
            const atTypesDependency = workspace.manifest[type].get(atTypesDescriptor.identHash);
            if (typeof atTypesDependency === `undefined`)
                continue;
            atTypesDependencies.push([type, atTypesDependency]);
        }
        // We only want workspaces that also depend on the appropriate @types package
        if (atTypesDependencies.length === 0)
            return core_2.miscUtils.mapAndFind.skip;
        return atTypesDependencies;
    });
    if (typeof projectSuggestions !== `undefined`) {
        for (const [dependencyType, atTypesDescriptor] of projectSuggestions) {
            workspace.manifest[dependencyType].set(atTypesDescriptor.identHash, atTypesDescriptor);
        }
    }
    else {
        // Return if the atTypes descriptor can't be resolved
        try {
            const normalizedAtTypesDescriptor = configuration.normalizeDependency(atTypesDescriptor);
            const atTypesCandidates = await resolver.getCandidates(normalizedAtTypesDescriptor, {}, resolveOptions);
            if (atTypesCandidates.length === 0) {
                return;
            }
        }
        catch {
            return;
        }
        workspace.manifest[plugin_essentials_1.suggestUtils.Target.DEVELOPMENT].set(atTypesDescriptor.identHash, atTypesDescriptor);
    }
};
const afterWorkspaceDependencyRemoval = async (workspace, dependencyTarget, descriptor) => {
    var _a;
    if (descriptor.scope === `types`)
        return;
    const { project } = workspace;
    const { configuration } = project;
    const tsEnableAutoTypes = (_a = configuration.get(`tsEnableAutoTypes`)) !== null && _a !== void 0 ? _a : fslib_1.xfs.existsSync(fslib_1.ppath.join(project.cwd, `tsconfig.json`));
    if (!tsEnableAutoTypes)
        return;
    const typesName = getTypesName(descriptor);
    const ident = core_2.structUtils.makeIdent(`types`, typesName);
    for (const type of core_1.Manifest.allDependencies) {
        const current = workspace.manifest[type].get(ident.identHash);
        if (typeof current === `undefined`)
            continue;
        workspace.manifest[type].delete(ident.identHash);
    }
};
const beforeWorkspacePacking = (workspace, rawManifest) => {
    if (rawManifest.publishConfig && rawManifest.publishConfig.typings)
        rawManifest.typings = rawManifest.publishConfig.typings;
    if (rawManifest.publishConfig && rawManifest.publishConfig.types) {
        rawManifest.types = rawManifest.publishConfig.types;
    }
};
const plugin = {
    configuration: {
        tsEnableAutoTypes: {
            description: `Whether Yarn should auto-install @types/ dependencies on 'yarn add'`,
            type: core_1.SettingsType.BOOLEAN,
            isNullable: true,
            default: null,
        },
    },
    hooks: {
        afterWorkspaceDependencyAddition,
        afterWorkspaceDependencyRemoval,
        beforeWorkspacePacking,
    },
};
// eslint-disable-next-line arca/no-default-export
exports.default = plugin;
