'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const require$$0 = require('zlib');
const path = require('path');
const module$1 = require('module');
const url = require('url');
const nodeUtils = require('util');
const assert = require('assert');
const fs = require('fs');
const crypto = require('crypto');
const os = require('os');

const _interopDefaultLegacy = e => e && typeof e === 'object' && 'default' in e ? e : { default: e };

const require$$0__default = /*#__PURE__*/_interopDefaultLegacy(require$$0);
const path__default = /*#__PURE__*/_interopDefaultLegacy(path);
const assert__default = /*#__PURE__*/_interopDefaultLegacy(assert);
const fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);

var LinkType = /* @__PURE__ */ ((LinkType2) => {
  LinkType2["HARD"] = `HARD`;
  LinkType2["SOFT"] = `SOFT`;
  return LinkType2;
})(LinkType || {});

const SAFE_TIME = 456789e3;

const PortablePath = {
  root: `/`,
  dot: `.`,
  parent: `..`
};
const Filename = {
  home: `~`,
  nodeModules: `node_modules`,
  manifest: `package.json`,
  lockfile: `yarn.lock`,
  virtual: `__virtual__`,
  pnpJs: `.pnp.js`,
  pnpCjs: `.pnp.cjs`,
  pnpData: `.pnp.data.json`,
  pnpEsmLoader: `.pnp.loader.mjs`,
  rc: `.yarnrc.yml`
};
const npath = Object.create(path__default.default);
const ppath = Object.create(path__default.default.posix);
npath.cwd = () => process.cwd();
ppath.cwd = () => toPortablePath(process.cwd());
ppath.resolve = (...segments) => {
  if (segments.length > 0 && ppath.isAbsolute(segments[0])) {
    return path__default.default.posix.resolve(...segments);
  } else {
    return path__default.default.posix.resolve(ppath.cwd(), ...segments);
  }
};
const contains = function(pathUtils, from, to) {
  from = pathUtils.normalize(from);
  to = pathUtils.normalize(to);
  if (from === to)
    return `.`;
  if (!from.endsWith(pathUtils.sep))
    from = from + pathUtils.sep;
  if (to.startsWith(from)) {
    return to.slice(from.length);
  } else {
    return null;
  }
};
npath.fromPortablePath = fromPortablePath;
npath.toPortablePath = toPortablePath;
npath.contains = (from, to) => contains(npath, from, to);
ppath.contains = (from, to) => contains(ppath, from, to);
const WINDOWS_PATH_REGEXP = /^([a-zA-Z]:.*)$/;
const UNC_WINDOWS_PATH_REGEXP = /^\/\/(\.\/)?(.*)$/;
const PORTABLE_PATH_REGEXP = /^\/([a-zA-Z]:.*)$/;
const UNC_PORTABLE_PATH_REGEXP = /^\/unc\/(\.dot\/)?(.*)$/;
function fromPortablePath(p) {
  if (process.platform !== `win32`)
    return p;
  let portablePathMatch, uncPortablePathMatch;
  if (portablePathMatch = p.match(PORTABLE_PATH_REGEXP))
    p = portablePathMatch[1];
  else if (uncPortablePathMatch = p.match(UNC_PORTABLE_PATH_REGEXP))
    p = `\\\\${uncPortablePathMatch[1] ? `.\\` : ``}${uncPortablePathMatch[2]}`;
  else
    return p;
  return p.replace(/\//g, `\\`);
}
function toPortablePath(p) {
  if (process.platform !== `win32`)
    return p;
  p = p.replace(/\\/g, `/`);
  let windowsPathMatch, uncWindowsPathMatch;
  if (windowsPathMatch = p.match(WINDOWS_PATH_REGEXP))
    p = `/${windowsPathMatch[1]}`;
  else if (uncWindowsPathMatch = p.match(UNC_WINDOWS_PATH_REGEXP))
    p = `/unc/${uncWindowsPathMatch[1] ? `.dot/` : ``}${uncWindowsPathMatch[2]}`;
  return p;
}
function convertPath(targetPathUtils, sourcePath) {
  return targetPathUtils === npath ? fromPortablePath(sourcePath) : toPortablePath(sourcePath);
}

const defaultTime = new Date(SAFE_TIME * 1e3);
const defaultTimeMs = defaultTime.getTime();
async function copyPromise(destinationFs, destination, sourceFs, source, opts) {
  const normalizedDestination = destinationFs.pathUtils.normalize(destination);
  const normalizedSource = sourceFs.pathUtils.normalize(source);
  const prelayout = [];
  const postlayout = [];
  const { atime, mtime } = opts.stableTime ? { atime: defaultTime, mtime: defaultTime } : await sourceFs.lstatPromise(normalizedSource);
  await destinationFs.mkdirpPromise(destinationFs.pathUtils.dirname(destination), { utimes: [atime, mtime] });
  await copyImpl(prelayout, postlayout, destinationFs, normalizedDestination, sourceFs, normalizedSource, { ...opts, didParentExist: true });
  for (const operation of prelayout)
    await operation();
  await Promise.all(postlayout.map((operation) => {
    return operation();
  }));
}
async function copyImpl(prelayout, postlayout, destinationFs, destination, sourceFs, source, opts) {
  var _a, _b, _c;
  const destinationStat = opts.didParentExist ? await maybeLStat(destinationFs, destination) : null;
  const sourceStat = await sourceFs.lstatPromise(source);
  const { atime, mtime } = opts.stableTime ? { atime: defaultTime, mtime: defaultTime } : sourceStat;
  let updated;
  switch (true) {
    case sourceStat.isDirectory():
      {
        updated = await copyFolder(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
      }
      break;
    case sourceStat.isFile():
      {
        updated = await copyFile(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
      }
      break;
    case sourceStat.isSymbolicLink():
      {
        updated = await copySymlink(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
      }
      break;
    default:
      {
        throw new Error(`Unsupported file type (${sourceStat.mode})`);
      }
  }
  if (((_a = opts.linkStrategy) == null ? void 0 : _a.type) !== `HardlinkFromIndex` || !sourceStat.isFile()) {
    if (updated || ((_b = destinationStat == null ? void 0 : destinationStat.mtime) == null ? void 0 : _b.getTime()) !== mtime.getTime() || ((_c = destinationStat == null ? void 0 : destinationStat.atime) == null ? void 0 : _c.getTime()) !== atime.getTime()) {
      postlayout.push(() => destinationFs.lutimesPromise(destination, atime, mtime));
      updated = true;
    }
    if (destinationStat === null || (destinationStat.mode & 511) !== (sourceStat.mode & 511)) {
      postlayout.push(() => destinationFs.chmodPromise(destination, sourceStat.mode & 511));
      updated = true;
    }
  }
  return updated;
}
async function maybeLStat(baseFs, p) {
  try {
    return await baseFs.lstatPromise(p);
  } catch (e) {
    return null;
  }
}
async function copyFolder(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
  if (destinationStat !== null && !destinationStat.isDirectory()) {
    if (opts.overwrite) {
      prelayout.push(async () => destinationFs.removePromise(destination));
      destinationStat = null;
    } else {
      return false;
    }
  }
  let updated = false;
  if (destinationStat === null) {
    prelayout.push(async () => {
      try {
        await destinationFs.mkdirPromise(destination, { mode: sourceStat.mode });
      } catch (err) {
        if (err.code !== `EEXIST`) {
          throw err;
        }
      }
    });
    updated = true;
  }
  const entries = await sourceFs.readdirPromise(source);
  const nextOpts = opts.didParentExist && !destinationStat ? { ...opts, didParentExist: false } : opts;
  if (opts.stableSort) {
    for (const entry of entries.sort()) {
      if (await copyImpl(prelayout, postlayout, destinationFs, destinationFs.pathUtils.join(destination, entry), sourceFs, sourceFs.pathUtils.join(source, entry), nextOpts)) {
        updated = true;
      }
    }
  } else {
    const entriesUpdateStatus = await Promise.all(entries.map(async (entry) => {
      await copyImpl(prelayout, postlayout, destinationFs, destinationFs.pathUtils.join(destination, entry), sourceFs, sourceFs.pathUtils.join(source, entry), nextOpts);
    }));
    if (entriesUpdateStatus.some((status) => status)) {
      updated = true;
    }
  }
  return updated;
}
async function copyFileViaIndex(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts, linkStrategy) {
  const sourceHash = await sourceFs.checksumFilePromise(source, { algorithm: `sha1` });
  const indexPath = destinationFs.pathUtils.join(linkStrategy.indexPath, sourceHash.slice(0, 2), `${sourceHash}.dat`);
  let AtomicBehavior;
  ((AtomicBehavior2) => {
    AtomicBehavior2[AtomicBehavior2["Lock"] = 0] = "Lock";
    AtomicBehavior2[AtomicBehavior2["Rename"] = 1] = "Rename";
  })(AtomicBehavior || (AtomicBehavior = {}));
  let atomicBehavior = 1 /* Rename */;
  let indexStat = await maybeLStat(destinationFs, indexPath);
  if (destinationStat) {
    const isDestinationHardlinkedFromIndex = indexStat && destinationStat.dev === indexStat.dev && destinationStat.ino === indexStat.ino;
    const isIndexModified = (indexStat == null ? void 0 : indexStat.mtimeMs) !== defaultTimeMs;
    if (isDestinationHardlinkedFromIndex) {
      if (isIndexModified && linkStrategy.autoRepair) {
        atomicBehavior = 0 /* Lock */;
        indexStat = null;
      }
    }
    if (!isDestinationHardlinkedFromIndex) {
      if (opts.overwrite) {
        prelayout.push(async () => destinationFs.removePromise(destination));
        destinationStat = null;
      } else {
        return false;
      }
    }
  }
  const tempPath = !indexStat && atomicBehavior === 1 /* Rename */ ? `${indexPath}.${Math.floor(Math.random() * 4294967296).toString(16).padStart(8, `0`)}` : null;
  let tempPathCleaned = false;
  prelayout.push(async () => {
    if (!indexStat) {
      if (atomicBehavior === 0 /* Lock */) {
        await destinationFs.lockPromise(indexPath, async () => {
          const content = await sourceFs.readFilePromise(source);
          await destinationFs.writeFilePromise(indexPath, content);
        });
      }
      if (atomicBehavior === 1 /* Rename */ && tempPath) {
        const content = await sourceFs.readFilePromise(source);
        await destinationFs.writeFilePromise(tempPath, content);
        try {
          await destinationFs.linkPromise(tempPath, indexPath);
        } catch (err) {
          if (err.code === `EEXIST`) {
            tempPathCleaned = true;
            await destinationFs.unlinkPromise(tempPath);
          } else {
            throw err;
          }
        }
      }
    }
    if (!destinationStat) {
      await destinationFs.linkPromise(indexPath, destination);
    }
  });
  postlayout.push(async () => {
    if (!indexStat)
      await destinationFs.lutimesPromise(indexPath, defaultTime, defaultTime);
    if (tempPath && !tempPathCleaned) {
      await destinationFs.unlinkPromise(tempPath);
    }
  });
  return false;
}
async function copyFileDirect(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
  if (destinationStat !== null) {
    if (opts.overwrite) {
      prelayout.push(async () => destinationFs.removePromise(destination));
      destinationStat = null;
    } else {
      return false;
    }
  }
  prelayout.push(async () => {
    const content = await sourceFs.readFilePromise(source);
    await destinationFs.writeFilePromise(destination, content);
  });
  return true;
}
async function copyFile(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
  var _a;
  if (((_a = opts.linkStrategy) == null ? void 0 : _a.type) === `HardlinkFromIndex`) {
    return copyFileViaIndex(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts, opts.linkStrategy);
  } else {
    return copyFileDirect(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
  }
}
async function copySymlink(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
  if (destinationStat !== null) {
    if (opts.overwrite) {
      prelayout.push(async () => destinationFs.removePromise(destination));
      destinationStat = null;
    } else {
      return false;
    }
  }
  prelayout.push(async () => {
    await destinationFs.symlinkPromise(convertPath(destinationFs.pathUtils, await sourceFs.readlinkPromise(source)), destination);
  });
  return true;
}

class FakeFS {
  constructor(pathUtils) {
    this.pathUtils = pathUtils;
  }
  async *genTraversePromise(init, { stableSort = false } = {}) {
    const stack = [init];
    while (stack.length > 0) {
      const p = stack.shift();
      const entry = await this.lstatPromise(p);
      if (entry.isDirectory()) {
        const entries = await this.readdirPromise(p);
        if (stableSort) {
          for (const entry2 of entries.sort()) {
            stack.push(this.pathUtils.join(p, entry2));
          }
        } else {
          throw new Error(`Not supported`);
        }
      } else {
        yield p;
      }
    }
  }
  async checksumFilePromise(path, { algorithm = `sha512` } = {}) {
    const fd = await this.openPromise(path, `r`);
    try {
      const CHUNK_SIZE = 65536;
      const chunk = Buffer.allocUnsafeSlow(CHUNK_SIZE);
      const hash = crypto.createHash(algorithm);
      let bytesRead = 0;
      while ((bytesRead = await this.readPromise(fd, chunk, 0, CHUNK_SIZE)) !== 0)
        hash.update(bytesRead === CHUNK_SIZE ? chunk : chunk.slice(0, bytesRead));
      return hash.digest(`hex`);
    } finally {
      await this.closePromise(fd);
    }
  }
  async removePromise(p, { recursive = true, maxRetries = 5 } = {}) {
    let stat;
    try {
      stat = await this.lstatPromise(p);
    } catch (error) {
      if (error.code === `ENOENT`) {
        return;
      } else {
        throw error;
      }
    }
    if (stat.isDirectory()) {
      if (recursive) {
        const entries = await this.readdirPromise(p);
        await Promise.all(entries.map((entry) => {
          return this.removePromise(this.pathUtils.resolve(p, entry));
        }));
      }
      for (let t = 0; t <= maxRetries; t++) {
        try {
          await this.rmdirPromise(p);
          break;
        } catch (error) {
          if (error.code !== `EBUSY` && error.code !== `ENOTEMPTY`) {
            throw error;
          } else if (t < maxRetries) {
            await new Promise((resolve) => setTimeout(resolve, t * 100));
          }
        }
      }
    } else {
      await this.unlinkPromise(p);
    }
  }
  removeSync(p, { recursive = true } = {}) {
    let stat;
    try {
      stat = this.lstatSync(p);
    } catch (error) {
      if (error.code === `ENOENT`) {
        return;
      } else {
        throw error;
      }
    }
    if (stat.isDirectory()) {
      if (recursive)
        for (const entry of this.readdirSync(p))
          this.removeSync(this.pathUtils.resolve(p, entry));
      this.rmdirSync(p);
    } else {
      this.unlinkSync(p);
    }
  }
  async mkdirpPromise(p, { chmod, utimes } = {}) {
    p = this.resolve(p);
    if (p === this.pathUtils.dirname(p))
      return void 0;
    const parts = p.split(this.pathUtils.sep);
    let createdDirectory;
    for (let u = 2; u <= parts.length; ++u) {
      const subPath = parts.slice(0, u).join(this.pathUtils.sep);
      if (!this.existsSync(subPath)) {
        try {
          await this.mkdirPromise(subPath);
        } catch (error) {
          if (error.code === `EEXIST`) {
            continue;
          } else {
            throw error;
          }
        }
        createdDirectory ?? (createdDirectory = subPath);
        if (chmod != null)
          await this.chmodPromise(subPath, chmod);
        if (utimes != null) {
          await this.utimesPromise(subPath, utimes[0], utimes[1]);
        } else {
          const parentStat = await this.statPromise(this.pathUtils.dirname(subPath));
          await this.utimesPromise(subPath, parentStat.atime, parentStat.mtime);
        }
      }
    }
    return createdDirectory;
  }
  mkdirpSync(p, { chmod, utimes } = {}) {
    p = this.resolve(p);
    if (p === this.pathUtils.dirname(p))
      return void 0;
    const parts = p.split(this.pathUtils.sep);
    let createdDirectory;
    for (let u = 2; u <= parts.length; ++u) {
      const subPath = parts.slice(0, u).join(this.pathUtils.sep);
      if (!this.existsSync(subPath)) {
        try {
          this.mkdirSync(subPath);
        } catch (error) {
          if (error.code === `EEXIST`) {
            continue;
          } else {
            throw error;
          }
        }
        createdDirectory ?? (createdDirectory = subPath);
        if (chmod != null)
          this.chmodSync(subPath, chmod);
        if (utimes != null) {
          this.utimesSync(subPath, utimes[0], utimes[1]);
        } else {
          const parentStat = this.statSync(this.pathUtils.dirname(subPath));
          this.utimesSync(subPath, parentStat.atime, parentStat.mtime);
        }
      }
    }
    return createdDirectory;
  }
  async copyPromise(destination, source, { baseFs = this, overwrite = true, stableSort = false, stableTime = false, linkStrategy = null } = {}) {
    return await copyPromise(this, destination, baseFs, source, { overwrite, stableSort, stableTime, linkStrategy });
  }
  copySync(destination, source, { baseFs = this, overwrite = true } = {}) {
    const stat = baseFs.lstatSync(source);
    const exists = this.existsSync(destination);
    if (stat.isDirectory()) {
      this.mkdirpSync(destination);
      const directoryListing = baseFs.readdirSync(source);
      for (const entry of directoryListing) {
        this.copySync(this.pathUtils.join(destination, entry), baseFs.pathUtils.join(source, entry), { baseFs, overwrite });
      }
    } else if (stat.isFile()) {
      if (!exists || overwrite) {
        if (exists)
          this.removeSync(destination);
        const content = baseFs.readFileSync(source);
        this.writeFileSync(destination, content);
      }
    } else if (stat.isSymbolicLink()) {
      if (!exists || overwrite) {
        if (exists)
          this.removeSync(destination);
        const target = baseFs.readlinkSync(source);
        this.symlinkSync(convertPath(this.pathUtils, target), destination);
      }
    } else {
      throw new Error(`Unsupported file type (file: ${source}, mode: 0o${stat.mode.toString(8).padStart(6, `0`)})`);
    }
    const mode = stat.mode & 511;
    this.chmodSync(destination, mode);
  }
  async changeFilePromise(p, content, opts = {}) {
    if (Buffer.isBuffer(content)) {
      return this.changeFileBufferPromise(p, content, opts);
    } else {
      return this.changeFileTextPromise(p, content, opts);
    }
  }
  async changeFileBufferPromise(p, content, { mode } = {}) {
    let current = Buffer.alloc(0);
    try {
      current = await this.readFilePromise(p);
    } catch (error) {
    }
    if (Buffer.compare(current, content) === 0)
      return;
    await this.writeFilePromise(p, content, { mode });
  }
  async changeFileTextPromise(p, content, { automaticNewlines, mode } = {}) {
    let current = ``;
    try {
      current = await this.readFilePromise(p, `utf8`);
    } catch (error) {
    }
    const normalizedContent = automaticNewlines ? normalizeLineEndings(current, content) : content;
    if (current === normalizedContent)
      return;
    await this.writeFilePromise(p, normalizedContent, { mode });
  }
  changeFileSync(p, content, opts = {}) {
    if (Buffer.isBuffer(content)) {
      return this.changeFileBufferSync(p, content, opts);
    } else {
      return this.changeFileTextSync(p, content, opts);
    }
  }
  changeFileBufferSync(p, content, { mode } = {}) {
    let current = Buffer.alloc(0);
    try {
      current = this.readFileSync(p);
    } catch (error) {
    }
    if (Buffer.compare(current, content) === 0)
      return;
    this.writeFileSync(p, content, { mode });
  }
  changeFileTextSync(p, content, { automaticNewlines = false, mode } = {}) {
    let current = ``;
    try {
      current = this.readFileSync(p, `utf8`);
    } catch (error) {
    }
    const normalizedContent = automaticNewlines ? normalizeLineEndings(current, content) : content;
    if (current === normalizedContent)
      return;
    this.writeFileSync(p, normalizedContent, { mode });
  }
  async movePromise(fromP, toP) {
    try {
      await this.renamePromise(fromP, toP);
    } catch (error) {
      if (error.code === `EXDEV`) {
        await this.copyPromise(toP, fromP);
        await this.removePromise(fromP);
      } else {
        throw error;
      }
    }
  }
  moveSync(fromP, toP) {
    try {
      this.renameSync(fromP, toP);
    } catch (error) {
      if (error.code === `EXDEV`) {
        this.copySync(toP, fromP);
        this.removeSync(fromP);
      } else {
        throw error;
      }
    }
  }
  async lockPromise(affectedPath, callback) {
    const lockPath = `${affectedPath}.flock`;
    const interval = 1e3 / 60;
    const startTime = Date.now();
    let fd = null;
    const isAlive = async () => {
      let pid;
      try {
        [pid] = await this.readJsonPromise(lockPath);
      } catch (error) {
        return Date.now() - startTime < 500;
      }
      try {
        process.kill(pid, 0);
        return true;
      } catch (error) {
        return false;
      }
    };
    while (fd === null) {
      try {
        fd = await this.openPromise(lockPath, `wx`);
      } catch (error) {
        if (error.code === `EEXIST`) {
          if (!await isAlive()) {
            try {
              await this.unlinkPromise(lockPath);
              continue;
            } catch (error2) {
            }
          }
          if (Date.now() - startTime < 60 * 1e3) {
            await new Promise((resolve) => setTimeout(resolve, interval));
          } else {
            throw new Error(`Couldn't acquire a lock in a reasonable time (via ${lockPath})`);
          }
        } else {
          throw error;
        }
      }
    }
    await this.writePromise(fd, JSON.stringify([process.pid]));
    try {
      return await callback();
    } finally {
      try {
        await this.closePromise(fd);
        await this.unlinkPromise(lockPath);
      } catch (error) {
      }
    }
  }
  async readJsonPromise(p) {
    const content = await this.readFilePromise(p, `utf8`);
    try {
      return JSON.parse(content);
    } catch (error) {
      error.message += ` (in ${p})`;
      throw error;
    }
  }
  readJsonSync(p) {
    const content = this.readFileSync(p, `utf8`);
    try {
      return JSON.parse(content);
    } catch (error) {
      error.message += ` (in ${p})`;
      throw error;
    }
  }
  async writeJsonPromise(p, data) {
    return await this.writeFilePromise(p, `${JSON.stringify(data, null, 2)}
`);
  }
  writeJsonSync(p, data) {
    return this.writeFileSync(p, `${JSON.stringify(data, null, 2)}
`);
  }
  async preserveTimePromise(p, cb) {
    const stat = await this.lstatPromise(p);
    const result = await cb();
    if (typeof result !== `undefined`)
      p = result;
    await this.lutimesPromise(p, stat.atime, stat.mtime);
  }
  async preserveTimeSync(p, cb) {
    const stat = this.lstatSync(p);
    const result = cb();
    if (typeof result !== `undefined`)
      p = result;
    this.lutimesSync(p, stat.atime, stat.mtime);
  }
}
class BasePortableFakeFS extends FakeFS {
  constructor() {
    super(ppath);
  }
}
function getEndOfLine(content) {
  const matches = content.match(/\r?\n/g);
  if (matches === null)
    return os.EOL;
  const crlf = matches.filter((nl) => nl === `\r
`).length;
  const lf = matches.length - crlf;
  return crlf > lf ? `\r
` : `
`;
}
function normalizeLineEndings(originalContent, newContent) {
  return newContent.replace(/\r?\n/g, getEndOfLine(originalContent));
}

class ProxiedFS extends FakeFS {
  getExtractHint(hints) {
    return this.baseFs.getExtractHint(hints);
  }
  resolve(path) {
    return this.mapFromBase(this.baseFs.resolve(this.mapToBase(path)));
  }
  getRealPath() {
    return this.mapFromBase(this.baseFs.getRealPath());
  }
  async openPromise(p, flags, mode) {
    return this.baseFs.openPromise(this.mapToBase(p), flags, mode);
  }
  openSync(p, flags, mode) {
    return this.baseFs.openSync(this.mapToBase(p), flags, mode);
  }
  async opendirPromise(p, opts) {
    return Object.assign(await this.baseFs.opendirPromise(this.mapToBase(p), opts), { path: p });
  }
  opendirSync(p, opts) {
    return Object.assign(this.baseFs.opendirSync(this.mapToBase(p), opts), { path: p });
  }
  async readPromise(fd, buffer, offset, length, position) {
    return await this.baseFs.readPromise(fd, buffer, offset, length, position);
  }
  readSync(fd, buffer, offset, length, position) {
    return this.baseFs.readSync(fd, buffer, offset, length, position);
  }
  async writePromise(fd, buffer, offset, length, position) {
    if (typeof buffer === `string`) {
      return await this.baseFs.writePromise(fd, buffer, offset);
    } else {
      return await this.baseFs.writePromise(fd, buffer, offset, length, position);
    }
  }
  writeSync(fd, buffer, offset, length, position) {
    if (typeof buffer === `string`) {
      return this.baseFs.writeSync(fd, buffer, offset);
    } else {
      return this.baseFs.writeSync(fd, buffer, offset, length, position);
    }
  }
  async closePromise(fd) {
    return this.baseFs.closePromise(fd);
  }
  closeSync(fd) {
    this.baseFs.closeSync(fd);
  }
  createReadStream(p, opts) {
    return this.baseFs.createReadStream(p !== null ? this.mapToBase(p) : p, opts);
  }
  createWriteStream(p, opts) {
    return this.baseFs.createWriteStream(p !== null ? this.mapToBase(p) : p, opts);
  }
  async realpathPromise(p) {
    return this.mapFromBase(await this.baseFs.realpathPromise(this.mapToBase(p)));
  }
  realpathSync(p) {
    return this.mapFromBase(this.baseFs.realpathSync(this.mapToBase(p)));
  }
  async existsPromise(p) {
    return this.baseFs.existsPromise(this.mapToBase(p));
  }
  existsSync(p) {
    return this.baseFs.existsSync(this.mapToBase(p));
  }
  accessSync(p, mode) {
    return this.baseFs.accessSync(this.mapToBase(p), mode);
  }
  async accessPromise(p, mode) {
    return this.baseFs.accessPromise(this.mapToBase(p), mode);
  }
  async statPromise(p, opts) {
    return this.baseFs.statPromise(this.mapToBase(p), opts);
  }
  statSync(p, opts) {
    return this.baseFs.statSync(this.mapToBase(p), opts);
  }
  async fstatPromise(fd, opts) {
    return this.baseFs.fstatPromise(fd, opts);
  }
  fstatSync(fd, opts) {
    return this.baseFs.fstatSync(fd, opts);
  }
  lstatPromise(p, opts) {
    return this.baseFs.lstatPromise(this.mapToBase(p), opts);
  }
  lstatSync(p, opts) {
    return this.baseFs.lstatSync(this.mapToBase(p), opts);
  }
  async fchmodPromise(fd, mask) {
    return this.baseFs.fchmodPromise(fd, mask);
  }
  fchmodSync(fd, mask) {
    return this.baseFs.fchmodSync(fd, mask);
  }
  async chmodPromise(p, mask) {
    return this.baseFs.chmodPromise(this.mapToBase(p), mask);
  }
  chmodSync(p, mask) {
    return this.baseFs.chmodSync(this.mapToBase(p), mask);
  }
  async fchownPromise(fd, uid, gid) {
    return this.baseFs.fchownPromise(fd, uid, gid);
  }
  fchownSync(fd, uid, gid) {
    return this.baseFs.fchownSync(fd, uid, gid);
  }
  async chownPromise(p, uid, gid) {
    return this.baseFs.chownPromise(this.mapToBase(p), uid, gid);
  }
  chownSync(p, uid, gid) {
    return this.baseFs.chownSync(this.mapToBase(p), uid, gid);
  }
  async renamePromise(oldP, newP) {
    return this.baseFs.renamePromise(this.mapToBase(oldP), this.mapToBase(newP));
  }
  renameSync(oldP, newP) {
    return this.baseFs.renameSync(this.mapToBase(oldP), this.mapToBase(newP));
  }
  async copyFilePromise(sourceP, destP, flags = 0) {
    return this.baseFs.copyFilePromise(this.mapToBase(sourceP), this.mapToBase(destP), flags);
  }
  copyFileSync(sourceP, destP, flags = 0) {
    return this.baseFs.copyFileSync(this.mapToBase(sourceP), this.mapToBase(destP), flags);
  }
  async appendFilePromise(p, content, opts) {
    return this.baseFs.appendFilePromise(this.fsMapToBase(p), content, opts);
  }
  appendFileSync(p, content, opts) {
    return this.baseFs.appendFileSync(this.fsMapToBase(p), content, opts);
  }
  async writeFilePromise(p, content, opts) {
    return this.baseFs.writeFilePromise(this.fsMapToBase(p), content, opts);
  }
  writeFileSync(p, content, opts) {
    return this.baseFs.writeFileSync(this.fsMapToBase(p), content, opts);
  }
  async unlinkPromise(p) {
    return this.baseFs.unlinkPromise(this.mapToBase(p));
  }
  unlinkSync(p) {
    return this.baseFs.unlinkSync(this.mapToBase(p));
  }
  async utimesPromise(p, atime, mtime) {
    return this.baseFs.utimesPromise(this.mapToBase(p), atime, mtime);
  }
  utimesSync(p, atime, mtime) {
    return this.baseFs.utimesSync(this.mapToBase(p), atime, mtime);
  }
  async lutimesPromise(p, atime, mtime) {
    return this.baseFs.lutimesPromise(this.mapToBase(p), atime, mtime);
  }
  lutimesSync(p, atime, mtime) {
    return this.baseFs.lutimesSync(this.mapToBase(p), atime, mtime);
  }
  async mkdirPromise(p, opts) {
    return this.baseFs.mkdirPromise(this.mapToBase(p), opts);
  }
  mkdirSync(p, opts) {
    return this.baseFs.mkdirSync(this.mapToBase(p), opts);
  }
  async rmdirPromise(p, opts) {
    return this.baseFs.rmdirPromise(this.mapToBase(p), opts);
  }
  rmdirSync(p, opts) {
    return this.baseFs.rmdirSync(this.mapToBase(p), opts);
  }
  async linkPromise(existingP, newP) {
    return this.baseFs.linkPromise(this.mapToBase(existingP), this.mapToBase(newP));
  }
  linkSync(existingP, newP) {
    return this.baseFs.linkSync(this.mapToBase(existingP), this.mapToBase(newP));
  }
  async symlinkPromise(target, p, type) {
    const mappedP = this.mapToBase(p);
    if (this.pathUtils.isAbsolute(target))
      return this.baseFs.symlinkPromise(this.mapToBase(target), mappedP, type);
    const mappedAbsoluteTarget = this.mapToBase(this.pathUtils.join(this.pathUtils.dirname(p), target));
    const mappedTarget = this.baseFs.pathUtils.relative(this.baseFs.pathUtils.dirname(mappedP), mappedAbsoluteTarget);
    return this.baseFs.symlinkPromise(mappedTarget, mappedP, type);
  }
  symlinkSync(target, p, type) {
    const mappedP = this.mapToBase(p);
    if (this.pathUtils.isAbsolute(target))
      return this.baseFs.symlinkSync(this.mapToBase(target), mappedP, type);
    const mappedAbsoluteTarget = this.mapToBase(this.pathUtils.join(this.pathUtils.dirname(p), target));
    const mappedTarget = this.baseFs.pathUtils.relative(this.baseFs.pathUtils.dirname(mappedP), mappedAbsoluteTarget);
    return this.baseFs.symlinkSync(mappedTarget, mappedP, type);
  }
  async readFilePromise(p, encoding) {
    return this.baseFs.readFilePromise(this.fsMapToBase(p), encoding);
  }
  readFileSync(p, encoding) {
    return this.baseFs.readFileSync(this.fsMapToBase(p), encoding);
  }
  async readdirPromise(p, opts) {
    return this.baseFs.readdirPromise(this.mapToBase(p), opts);
  }
  readdirSync(p, opts) {
    return this.baseFs.readdirSync(this.mapToBase(p), opts);
  }
  async readlinkPromise(p) {
    return this.mapFromBase(await this.baseFs.readlinkPromise(this.mapToBase(p)));
  }
  readlinkSync(p) {
    return this.mapFromBase(this.baseFs.readlinkSync(this.mapToBase(p)));
  }
  async truncatePromise(p, len) {
    return this.baseFs.truncatePromise(this.mapToBase(p), len);
  }
  truncateSync(p, len) {
    return this.baseFs.truncateSync(this.mapToBase(p), len);
  }
  async ftruncatePromise(fd, len) {
    return this.baseFs.ftruncatePromise(fd, len);
  }
  ftruncateSync(fd, len) {
    return this.baseFs.ftruncateSync(fd, len);
  }
  watch(p, a, b) {
    return this.baseFs.watch(
      this.mapToBase(p),
      a,
      b
    );
  }
  watchFile(p, a, b) {
    return this.baseFs.watchFile(
      this.mapToBase(p),
      a,
      b
    );
  }
  unwatchFile(p, cb) {
    return this.baseFs.unwatchFile(this.mapToBase(p), cb);
  }
  fsMapToBase(p) {
    if (typeof p === `number`) {
      return p;
    } else {
      return this.mapToBase(p);
    }
  }
}

class NodeFS extends BasePortableFakeFS {
  constructor(realFs = fs__default.default) {
    super();
    this.realFs = realFs;
  }
  getExtractHint() {
    return false;
  }
  getRealPath() {
    return PortablePath.root;
  }
  resolve(p) {
    return ppath.resolve(p);
  }
  async openPromise(p, flags, mode) {
    return await new Promise((resolve, reject) => {
      this.realFs.open(npath.fromPortablePath(p), flags, mode, this.makeCallback(resolve, reject));
    });
  }
  openSync(p, flags, mode) {
    return this.realFs.openSync(npath.fromPortablePath(p), flags, mode);
  }
  async opendirPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      if (typeof opts !== `undefined`) {
        this.realFs.opendir(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.opendir(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
      }
    }).then((dir) => {
      return Object.defineProperty(dir, `path`, { value: p, configurable: true, writable: true });
    });
  }
  opendirSync(p, opts) {
    const dir = typeof opts !== `undefined` ? this.realFs.opendirSync(npath.fromPortablePath(p), opts) : this.realFs.opendirSync(npath.fromPortablePath(p));
    return Object.defineProperty(dir, `path`, { value: p, configurable: true, writable: true });
  }
  async readPromise(fd, buffer, offset = 0, length = 0, position = -1) {
    return await new Promise((resolve, reject) => {
      this.realFs.read(fd, buffer, offset, length, position, (error, bytesRead) => {
        if (error) {
          reject(error);
        } else {
          resolve(bytesRead);
        }
      });
    });
  }
  readSync(fd, buffer, offset, length, position) {
    return this.realFs.readSync(fd, buffer, offset, length, position);
  }
  async writePromise(fd, buffer, offset, length, position) {
    return await new Promise((resolve, reject) => {
      if (typeof buffer === `string`) {
        return this.realFs.write(fd, buffer, offset, this.makeCallback(resolve, reject));
      } else {
        return this.realFs.write(fd, buffer, offset, length, position, this.makeCallback(resolve, reject));
      }
    });
  }
  writeSync(fd, buffer, offset, length, position) {
    if (typeof buffer === `string`) {
      return this.realFs.writeSync(fd, buffer, offset);
    } else {
      return this.realFs.writeSync(fd, buffer, offset, length, position);
    }
  }
  async closePromise(fd) {
    await new Promise((resolve, reject) => {
      this.realFs.close(fd, this.makeCallback(resolve, reject));
    });
  }
  closeSync(fd) {
    this.realFs.closeSync(fd);
  }
  createReadStream(p, opts) {
    const realPath = p !== null ? npath.fromPortablePath(p) : p;
    return this.realFs.createReadStream(realPath, opts);
  }
  createWriteStream(p, opts) {
    const realPath = p !== null ? npath.fromPortablePath(p) : p;
    return this.realFs.createWriteStream(realPath, opts);
  }
  async realpathPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.realpath(npath.fromPortablePath(p), {}, this.makeCallback(resolve, reject));
    }).then((path) => {
      return npath.toPortablePath(path);
    });
  }
  realpathSync(p) {
    return npath.toPortablePath(this.realFs.realpathSync(npath.fromPortablePath(p), {}));
  }
  async existsPromise(p) {
    return await new Promise((resolve) => {
      this.realFs.exists(npath.fromPortablePath(p), resolve);
    });
  }
  accessSync(p, mode) {
    return this.realFs.accessSync(npath.fromPortablePath(p), mode);
  }
  async accessPromise(p, mode) {
    return await new Promise((resolve, reject) => {
      this.realFs.access(npath.fromPortablePath(p), mode, this.makeCallback(resolve, reject));
    });
  }
  existsSync(p) {
    return this.realFs.existsSync(npath.fromPortablePath(p));
  }
  async statPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      if (opts) {
        this.realFs.stat(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.stat(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
      }
    });
  }
  statSync(p, opts) {
    if (opts) {
      return this.realFs.statSync(npath.fromPortablePath(p), opts);
    } else {
      return this.realFs.statSync(npath.fromPortablePath(p));
    }
  }
  async fstatPromise(fd, opts) {
    return await new Promise((resolve, reject) => {
      if (opts) {
        this.realFs.fstat(fd, opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.fstat(fd, this.makeCallback(resolve, reject));
      }
    });
  }
  fstatSync(fd, opts) {
    if (opts) {
      return this.realFs.fstatSync(fd, opts);
    } else {
      return this.realFs.fstatSync(fd);
    }
  }
  async lstatPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      if (opts) {
        this.realFs.lstat(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.lstat(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
      }
    });
  }
  lstatSync(p, opts) {
    if (opts) {
      return this.realFs.lstatSync(npath.fromPortablePath(p), opts);
    } else {
      return this.realFs.lstatSync(npath.fromPortablePath(p));
    }
  }
  async fchmodPromise(fd, mask) {
    return await new Promise((resolve, reject) => {
      this.realFs.fchmod(fd, mask, this.makeCallback(resolve, reject));
    });
  }
  fchmodSync(fd, mask) {
    return this.realFs.fchmodSync(fd, mask);
  }
  async chmodPromise(p, mask) {
    return await new Promise((resolve, reject) => {
      this.realFs.chmod(npath.fromPortablePath(p), mask, this.makeCallback(resolve, reject));
    });
  }
  chmodSync(p, mask) {
    return this.realFs.chmodSync(npath.fromPortablePath(p), mask);
  }
  async fchownPromise(fd, uid, gid) {
    return await new Promise((resolve, reject) => {
      this.realFs.fchown(fd, uid, gid, this.makeCallback(resolve, reject));
    });
  }
  fchownSync(fd, uid, gid) {
    return this.realFs.fchownSync(fd, uid, gid);
  }
  async chownPromise(p, uid, gid) {
    return await new Promise((resolve, reject) => {
      this.realFs.chown(npath.fromPortablePath(p), uid, gid, this.makeCallback(resolve, reject));
    });
  }
  chownSync(p, uid, gid) {
    return this.realFs.chownSync(npath.fromPortablePath(p), uid, gid);
  }
  async renamePromise(oldP, newP) {
    return await new Promise((resolve, reject) => {
      this.realFs.rename(npath.fromPortablePath(oldP), npath.fromPortablePath(newP), this.makeCallback(resolve, reject));
    });
  }
  renameSync(oldP, newP) {
    return this.realFs.renameSync(npath.fromPortablePath(oldP), npath.fromPortablePath(newP));
  }
  async copyFilePromise(sourceP, destP, flags = 0) {
    return await new Promise((resolve, reject) => {
      this.realFs.copyFile(npath.fromPortablePath(sourceP), npath.fromPortablePath(destP), flags, this.makeCallback(resolve, reject));
    });
  }
  copyFileSync(sourceP, destP, flags = 0) {
    return this.realFs.copyFileSync(npath.fromPortablePath(sourceP), npath.fromPortablePath(destP), flags);
  }
  async appendFilePromise(p, content, opts) {
    return await new Promise((resolve, reject) => {
      const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
      if (opts) {
        this.realFs.appendFile(fsNativePath, content, opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.appendFile(fsNativePath, content, this.makeCallback(resolve, reject));
      }
    });
  }
  appendFileSync(p, content, opts) {
    const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
    if (opts) {
      this.realFs.appendFileSync(fsNativePath, content, opts);
    } else {
      this.realFs.appendFileSync(fsNativePath, content);
    }
  }
  async writeFilePromise(p, content, opts) {
    return await new Promise((resolve, reject) => {
      const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
      if (opts) {
        this.realFs.writeFile(fsNativePath, content, opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.writeFile(fsNativePath, content, this.makeCallback(resolve, reject));
      }
    });
  }
  writeFileSync(p, content, opts) {
    const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
    if (opts) {
      this.realFs.writeFileSync(fsNativePath, content, opts);
    } else {
      this.realFs.writeFileSync(fsNativePath, content);
    }
  }
  async unlinkPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.unlink(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
    });
  }
  unlinkSync(p) {
    return this.realFs.unlinkSync(npath.fromPortablePath(p));
  }
  async utimesPromise(p, atime, mtime) {
    return await new Promise((resolve, reject) => {
      this.realFs.utimes(npath.fromPortablePath(p), atime, mtime, this.makeCallback(resolve, reject));
    });
  }
  utimesSync(p, atime, mtime) {
    this.realFs.utimesSync(npath.fromPortablePath(p), atime, mtime);
  }
  async lutimesPromise(p, atime, mtime) {
    return await new Promise((resolve, reject) => {
      this.realFs.lutimes(npath.fromPortablePath(p), atime, mtime, this.makeCallback(resolve, reject));
    });
  }
  lutimesSync(p, atime, mtime) {
    this.realFs.lutimesSync(npath.fromPortablePath(p), atime, mtime);
  }
  async mkdirPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      this.realFs.mkdir(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
    });
  }
  mkdirSync(p, opts) {
    return this.realFs.mkdirSync(npath.fromPortablePath(p), opts);
  }
  async rmdirPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      if (opts) {
        this.realFs.rmdir(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.rmdir(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
      }
    });
  }
  rmdirSync(p, opts) {
    return this.realFs.rmdirSync(npath.fromPortablePath(p), opts);
  }
  async linkPromise(existingP, newP) {
    return await new Promise((resolve, reject) => {
      this.realFs.link(npath.fromPortablePath(existingP), npath.fromPortablePath(newP), this.makeCallback(resolve, reject));
    });
  }
  linkSync(existingP, newP) {
    return this.realFs.linkSync(npath.fromPortablePath(existingP), npath.fromPortablePath(newP));
  }
  async symlinkPromise(target, p, type) {
    return await new Promise((resolve, reject) => {
      this.realFs.symlink(npath.fromPortablePath(target.replace(/\/+$/, ``)), npath.fromPortablePath(p), type, this.makeCallback(resolve, reject));
    });
  }
  symlinkSync(target, p, type) {
    return this.realFs.symlinkSync(npath.fromPortablePath(target.replace(/\/+$/, ``)), npath.fromPortablePath(p), type);
  }
  async readFilePromise(p, encoding) {
    return await new Promise((resolve, reject) => {
      const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
      this.realFs.readFile(fsNativePath, encoding, this.makeCallback(resolve, reject));
    });
  }
  readFileSync(p, encoding) {
    const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
    return this.realFs.readFileSync(fsNativePath, encoding);
  }
  async readdirPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      if (opts == null ? void 0 : opts.withFileTypes) {
        this.realFs.readdir(npath.fromPortablePath(p), { withFileTypes: true }, this.makeCallback(resolve, reject));
      } else {
        this.realFs.readdir(npath.fromPortablePath(p), this.makeCallback((value) => resolve(value), reject));
      }
    });
  }
  readdirSync(p, opts) {
    if (opts == null ? void 0 : opts.withFileTypes) {
      return this.realFs.readdirSync(npath.fromPortablePath(p), { withFileTypes: true });
    } else {
      return this.realFs.readdirSync(npath.fromPortablePath(p));
    }
  }
  async readlinkPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.readlink(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
    }).then((path) => {
      return npath.toPortablePath(path);
    });
  }
  readlinkSync(p) {
    return npath.toPortablePath(this.realFs.readlinkSync(npath.fromPortablePath(p)));
  }
  async truncatePromise(p, len) {
    return await new Promise((resolve, reject) => {
      this.realFs.truncate(npath.fromPortablePath(p), len, this.makeCallback(resolve, reject));
    });
  }
  truncateSync(p, len) {
    return this.realFs.truncateSync(npath.fromPortablePath(p), len);
  }
  async ftruncatePromise(fd, len) {
    return await new Promise((resolve, reject) => {
      this.realFs.ftruncate(fd, len, this.makeCallback(resolve, reject));
    });
  }
  ftruncateSync(fd, len) {
    return this.realFs.ftruncateSync(fd, len);
  }
  watch(p, a, b) {
    return this.realFs.watch(
      npath.fromPortablePath(p),
      a,
      b
    );
  }
  watchFile(p, a, b) {
    return this.realFs.watchFile(
      npath.fromPortablePath(p),
      a,
      b
    );
  }
  unwatchFile(p, cb) {
    return this.realFs.unwatchFile(npath.fromPortablePath(p), cb);
  }
  makeCallback(resolve, reject) {
    return (err, result) => {
      if (err) {
        reject(err);
      } else {
        resolve(result);
      }
    };
  }
}

const NUMBER_REGEXP = /^[0-9]+$/;
const VIRTUAL_REGEXP = /^(\/(?:[^/]+\/)*?(?:\$\$virtual|__virtual__))((?:\/((?:[^/]+-)?[a-f0-9]+)(?:\/([^/]+))?)?((?:\/.*)?))$/;
const VALID_COMPONENT = /^([^/]+-)?[a-f0-9]+$/;
class VirtualFS extends ProxiedFS {
  constructor({ baseFs = new NodeFS() } = {}) {
    super(ppath);
    this.baseFs = baseFs;
  }
  static makeVirtualPath(base, component, to) {
    if (ppath.basename(base) !== `__virtual__`)
      throw new Error(`Assertion failed: Virtual folders must be named "__virtual__"`);
    if (!ppath.basename(component).match(VALID_COMPONENT))
      throw new Error(`Assertion failed: Virtual components must be ended by an hexadecimal hash`);
    const target = ppath.relative(ppath.dirname(base), to);
    const segments = target.split(`/`);
    let depth = 0;
    while (depth < segments.length && segments[depth] === `..`)
      depth += 1;
    const finalSegments = segments.slice(depth);
    const fullVirtualPath = ppath.join(base, component, String(depth), ...finalSegments);
    return fullVirtualPath;
  }
  static resolveVirtual(p) {
    const match = p.match(VIRTUAL_REGEXP);
    if (!match || !match[3] && match[5])
      return p;
    const target = ppath.dirname(match[1]);
    if (!match[3] || !match[4])
      return target;
    const isnum = NUMBER_REGEXP.test(match[4]);
    if (!isnum)
      return p;
    const depth = Number(match[4]);
    const backstep = `../`.repeat(depth);
    const subpath = match[5] || `.`;
    return VirtualFS.resolveVirtual(ppath.join(target, backstep, subpath));
  }
  getExtractHint(hints) {
    return this.baseFs.getExtractHint(hints);
  }
  getRealPath() {
    return this.baseFs.getRealPath();
  }
  realpathSync(p) {
    const match = p.match(VIRTUAL_REGEXP);
    if (!match)
      return this.baseFs.realpathSync(p);
    if (!match[5])
      return p;
    const realpath = this.baseFs.realpathSync(this.mapToBase(p));
    return VirtualFS.makeVirtualPath(match[1], match[3], realpath);
  }
  async realpathPromise(p) {
    const match = p.match(VIRTUAL_REGEXP);
    if (!match)
      return await this.baseFs.realpathPromise(p);
    if (!match[5])
      return p;
    const realpath = await this.baseFs.realpathPromise(this.mapToBase(p));
    return VirtualFS.makeVirtualPath(match[1], match[3], realpath);
  }
  mapToBase(p) {
    if (p === ``)
      return p;
    if (this.pathUtils.isAbsolute(p))
      return VirtualFS.resolveVirtual(p);
    const resolvedRoot = VirtualFS.resolveVirtual(this.baseFs.resolve(PortablePath.dot));
    const resolvedP = VirtualFS.resolveVirtual(this.baseFs.resolve(p));
    return ppath.relative(resolvedRoot, resolvedP) || PortablePath.dot;
  }
  mapFromBase(p) {
    return p;
  }
}

const prettyJsonMachine = {
  ["DEFAULT" /* DEFAULT */]: {
    collapsed: false,
    next: {
      [`*`]: "DEFAULT" /* DEFAULT */
    }
  },
  ["TOP_LEVEL" /* TOP_LEVEL */]: {
    collapsed: false,
    next: {
      [`fallbackExclusionList`]: "FALLBACK_EXCLUSION_LIST" /* FALLBACK_EXCLUSION_LIST */,
      [`packageRegistryData`]: "PACKAGE_REGISTRY_DATA" /* PACKAGE_REGISTRY_DATA */,
      [`*`]: "DEFAULT" /* DEFAULT */
    }
  },
  ["FALLBACK_EXCLUSION_LIST" /* FALLBACK_EXCLUSION_LIST */]: {
    collapsed: false,
    next: {
      [`*`]: "FALLBACK_EXCLUSION_ENTRIES" /* FALLBACK_EXCLUSION_ENTRIES */
    }
  },
  ["FALLBACK_EXCLUSION_ENTRIES" /* FALLBACK_EXCLUSION_ENTRIES */]: {
    collapsed: true,
    next: {
      [`*`]: "FALLBACK_EXCLUSION_DATA" /* FALLBACK_EXCLUSION_DATA */
    }
  },
  ["FALLBACK_EXCLUSION_DATA" /* FALLBACK_EXCLUSION_DATA */]: {
    collapsed: true,
    next: {
      [`*`]: "DEFAULT" /* DEFAULT */
    }
  },
  ["PACKAGE_REGISTRY_DATA" /* PACKAGE_REGISTRY_DATA */]: {
    collapsed: false,
    next: {
      [`*`]: "PACKAGE_REGISTRY_ENTRIES" /* PACKAGE_REGISTRY_ENTRIES */
    }
  },
  ["PACKAGE_REGISTRY_ENTRIES" /* PACKAGE_REGISTRY_ENTRIES */]: {
    collapsed: true,
    next: {
      [`*`]: "PACKAGE_STORE_DATA" /* PACKAGE_STORE_DATA */
    }
  },
  ["PACKAGE_STORE_DATA" /* PACKAGE_STORE_DATA */]: {
    collapsed: false,
    next: {
      [`*`]: "PACKAGE_STORE_ENTRIES" /* PACKAGE_STORE_ENTRIES */
    }
  },
  ["PACKAGE_STORE_ENTRIES" /* PACKAGE_STORE_ENTRIES */]: {
    collapsed: true,
    next: {
      [`*`]: "PACKAGE_INFORMATION_DATA" /* PACKAGE_INFORMATION_DATA */
    }
  },
  ["PACKAGE_INFORMATION_DATA" /* PACKAGE_INFORMATION_DATA */]: {
    collapsed: false,
    next: {
      [`packageDependencies`]: "PACKAGE_DEPENDENCIES" /* PACKAGE_DEPENDENCIES */,
      [`*`]: "DEFAULT" /* DEFAULT */
    }
  },
  ["PACKAGE_DEPENDENCIES" /* PACKAGE_DEPENDENCIES */]: {
    collapsed: false,
    next: {
      [`*`]: "PACKAGE_DEPENDENCY" /* PACKAGE_DEPENDENCY */
    }
  },
  ["PACKAGE_DEPENDENCY" /* PACKAGE_DEPENDENCY */]: {
    collapsed: true,
    next: {
      [`*`]: "DEFAULT" /* DEFAULT */
    }
  }
};
function generateCollapsedArray(data, state, indent) {
  let result = ``;
  result += `[`;
  for (let t = 0, T = data.length; t < T; ++t) {
    result += generateNext(String(t), data[t], state, indent).replace(/^ +/g, ``);
    if (t + 1 < T) {
      result += `, `;
    }
  }
  result += `]`;
  return result;
}
function generateExpandedArray(data, state, indent) {
  const nextIndent = `${indent}  `;
  let result = ``;
  result += indent;
  result += `[
`;
  for (let t = 0, T = data.length; t < T; ++t) {
    result += nextIndent + generateNext(String(t), data[t], state, nextIndent).replace(/^ +/, ``);
    if (t + 1 < T)
      result += `,`;
    result += `
`;
  }
  result += indent;
  result += `]`;
  return result;
}
function generateCollapsedObject(data, state, indent) {
  const keys = Object.keys(data);
  let result = ``;
  result += `{`;
  for (let t = 0, T = keys.length, keysPrinted = 0; t < T; ++t) {
    const key = keys[t];
    const value = data[key];
    if (typeof value === `undefined`)
      continue;
    if (keysPrinted !== 0)
      result += `, `;
    result += JSON.stringify(key);
    result += `: `;
    result += generateNext(key, value, state, indent).replace(/^ +/g, ``);
    keysPrinted += 1;
  }
  result += `}`;
  return result;
}
function generateExpandedObject(data, state, indent) {
  const keys = Object.keys(data);
  const nextIndent = `${indent}  `;
  let result = ``;
  result += indent;
  result += `{
`;
  let keysPrinted = 0;
  for (let t = 0, T = keys.length; t < T; ++t) {
    const key = keys[t];
    const value = data[key];
    if (typeof value === `undefined`)
      continue;
    if (keysPrinted !== 0) {
      result += `,`;
      result += `
`;
    }
    result += nextIndent;
    result += JSON.stringify(key);
    result += `: `;
    result += generateNext(key, value, state, nextIndent).replace(/^ +/g, ``);
    keysPrinted += 1;
  }
  if (keysPrinted !== 0)
    result += `
`;
  result += indent;
  result += `}`;
  return result;
}
function generateNext(key, data, state, indent) {
  const { next } = prettyJsonMachine[state];
  const nextState = next[key] || next[`*`];
  return generate(data, nextState, indent);
}
function generate(data, state, indent) {
  const { collapsed } = prettyJsonMachine[state];
  if (Array.isArray(data)) {
    if (collapsed) {
      return generateCollapsedArray(data, state, indent);
    } else {
      return generateExpandedArray(data, state, indent);
    }
  }
  if (typeof data === `object` && data !== null) {
    if (collapsed) {
      return generateCollapsedObject(data, state, indent);
    } else {
      return generateExpandedObject(data, state, indent);
    }
  }
  return JSON.stringify(data);
}
function generatePrettyJson(data) {
  return generate(data, "TOP_LEVEL" /* TOP_LEVEL */, ``);
}

function sortMap(values, mappers) {
  const asArray = Array.from(values);
  if (!Array.isArray(mappers))
    mappers = [mappers];
  const stringified = [];
  for (const mapper of mappers)
    stringified.push(asArray.map((value) => mapper(value)));
  const indices = asArray.map((_, index) => index);
  indices.sort((a, b) => {
    for (const layer of stringified) {
      const comparison = layer[a] < layer[b] ? -1 : layer[a] > layer[b] ? 1 : 0;
      if (comparison !== 0) {
        return comparison;
      }
    }
    return 0;
  });
  return indices.map((index) => {
    return asArray[index];
  });
}
function generateFallbackExclusionList(settings) {
  const fallbackExclusionList = /* @__PURE__ */ new Map();
  const sortedData = sortMap(settings.fallbackExclusionList || [], [
    ({ name, reference }) => name,
    ({ name, reference }) => reference
  ]);
  for (const { name, reference } of sortedData) {
    let references = fallbackExclusionList.get(name);
    if (typeof references === `undefined`)
      fallbackExclusionList.set(name, references = /* @__PURE__ */ new Set());
    references.add(reference);
  }
  return Array.from(fallbackExclusionList).map(([name, references]) => {
    return [name, Array.from(references)];
  });
}
function generateFallbackPoolData(settings) {
  return sortMap(settings.fallbackPool || [], ([name]) => name);
}
function generatePackageRegistryData(settings) {
  const packageRegistryData = [];
  for (const [packageName, packageStore] of sortMap(settings.packageRegistry, ([packageName2]) => packageName2 === null ? `0` : `1${packageName2}`)) {
    const packageStoreData = [];
    packageRegistryData.push([packageName, packageStoreData]);
    for (const [packageReference, { packageLocation, packageDependencies, packagePeers, linkType, discardFromLookup }] of sortMap(packageStore, ([packageReference2]) => packageReference2 === null ? `0` : `1${packageReference2}`)) {
      const normalizedDependencies = [];
      if (packageName !== null && packageReference !== null && !packageDependencies.has(packageName))
        normalizedDependencies.push([packageName, packageReference]);
      for (const [dependencyName, dependencyReference] of sortMap(packageDependencies.entries(), ([dependencyName2]) => dependencyName2))
        normalizedDependencies.push([dependencyName, dependencyReference]);
      const normalizedPeers = packagePeers && packagePeers.size > 0 ? Array.from(packagePeers) : void 0;
      const normalizedDiscardFromLookup = discardFromLookup ? discardFromLookup : void 0;
      packageStoreData.push([packageReference, {
        packageLocation,
        packageDependencies: normalizedDependencies,
        packagePeers: normalizedPeers,
        linkType,
        discardFromLookup: normalizedDiscardFromLookup
      }]);
    }
  }
  return packageRegistryData;
}
function generateSerializedState(settings) {
  return {
    __info: [
      `This file is automatically generated. Do not touch it, or risk`,
      `your modifications being lost.`
    ],
    dependencyTreeRoots: settings.dependencyTreeRoots,
    enableTopLevelFallback: settings.enableTopLevelFallback || false,
    ignorePatternData: settings.ignorePattern || null,
    fallbackExclusionList: generateFallbackExclusionList(settings),
    fallbackPool: generateFallbackPoolData(settings),
    packageRegistryData: generatePackageRegistryData(settings)
  };
}

let hook$1;
var hook_1 = () => {
  if (typeof hook$1 === `undefined`)
    hook$1 = require$$0__default.default.brotliDecompressSync(Buffer.from("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", "base64")).toString();
  return hook$1;
};

function generateLoader(shebang, loader) {
  return [
    shebang ? `${shebang}
` : ``,
    `/* eslint-disable */
`,
    `"use strict";
`,
    `
`,
    loader,
    `
`,
    hook_1()
  ].join(``);
}
function generateJsonString(data) {
  return JSON.stringify(data, null, 2);
}
function generateStringLiteral(value) {
  return `'${value.replace(/\\/g, `\\\\`).replace(/'/g, `\\'`).replace(/\n/g, `\\
`)}'`;
}
function generateInlinedSetup(data) {
  return [
    `const RAW_RUNTIME_STATE =
`,
    `${generateStringLiteral(generatePrettyJson(data))};

`,
    `function $$SETUP_STATE(hydrateRuntimeState, basePath) {
`,
    `  return hydrateRuntimeState(JSON.parse(RAW_RUNTIME_STATE), {basePath: basePath || __dirname});
`,
    `}
`
  ].join(``);
}
function generateSplitSetup() {
  return [
    `function $$SETUP_STATE(hydrateRuntimeState, basePath) {
`,
    `  return hydrateRuntimeState(require(${JSON.stringify(`./${Filename.pnpData}`)}), {basePath: basePath || __dirname});
`,
    `}
`
  ].join(``);
}
function generateInlinedScript(settings) {
  const data = generateSerializedState(settings);
  const setup = generateInlinedSetup(data);
  const loaderFile = generateLoader(settings.shebang, setup);
  return loaderFile;
}
function generateSplitScript(settings) {
  const data = generateSerializedState(settings);
  const setup = generateSplitSetup();
  const loaderFile = generateLoader(settings.shebang, setup);
  return { dataFile: generateJsonString(data), loaderFile };
}

function hydrateRuntimeState(data, { basePath }) {
  const portablePath = npath.toPortablePath(basePath);
  const absolutePortablePath = ppath.resolve(portablePath);
  const ignorePattern = data.ignorePatternData !== null ? new RegExp(data.ignorePatternData) : null;
  const packageLocatorsByLocations = /* @__PURE__ */ new Map();
  const packageRegistry = new Map(data.packageRegistryData.map(([packageName, packageStoreData]) => {
    return [packageName, new Map(packageStoreData.map(([packageReference, packageInformationData]) => {
      if (packageName === null !== (packageReference === null))
        throw new Error(`Assertion failed: The name and reference should be null, or neither should`);
      const discardFromLookup = packageInformationData.discardFromLookup ?? false;
      const packageLocator = { name: packageName, reference: packageReference };
      const entry = packageLocatorsByLocations.get(packageInformationData.packageLocation);
      if (!entry) {
        packageLocatorsByLocations.set(packageInformationData.packageLocation, { locator: packageLocator, discardFromLookup });
      } else {
        entry.discardFromLookup = entry.discardFromLookup && discardFromLookup;
        if (!discardFromLookup) {
          entry.locator = packageLocator;
        }
      }
      let resolvedPackageLocation = null;
      return [packageReference, {
        packageDependencies: new Map(packageInformationData.packageDependencies),
        packagePeers: new Set(packageInformationData.packagePeers),
        linkType: packageInformationData.linkType,
        discardFromLookup,
        get packageLocation() {
          return resolvedPackageLocation || (resolvedPackageLocation = ppath.join(absolutePortablePath, packageInformationData.packageLocation));
        }
      }];
    }))];
  }));
  const fallbackExclusionList = new Map(data.fallbackExclusionList.map(([packageName, packageReferences]) => {
    return [packageName, new Set(packageReferences)];
  }));
  const fallbackPool = new Map(data.fallbackPool);
  const dependencyTreeRoots = data.dependencyTreeRoots;
  const enableTopLevelFallback = data.enableTopLevelFallback;
  return {
    basePath: portablePath,
    dependencyTreeRoots,
    enableTopLevelFallback,
    fallbackExclusionList,
    fallbackPool,
    ignorePattern,
    packageLocatorsByLocations,
    packageRegistry
  };
}

/**
 * @param {object} exports
 * @param {Set<string>} keys
 */
function loop(exports, keys) {
	if (typeof exports === 'string') {
		return exports;
	}

	if (exports) {
		let idx, tmp;
		if (Array.isArray(exports)) {
			for (idx=0; idx < exports.length; idx++) {
				if (tmp = loop(exports[idx], keys)) return tmp;
			}
		} else {
			for (idx in exports) {
				if (keys.has(idx)) {
					return loop(exports[idx], keys);
				}
			}
		}
	}
}

/**
 * @param {string} name The package name
 * @param {string} entry The target entry, eg "."
 * @param {number} [condition] Unmatched condition?
 */
function bail(name, entry, condition) {
	throw new Error(
		condition
		? `No known conditions for "${entry}" entry in "${name}" package`
		: `Missing "${entry}" export in "${name}" package`
	);
}

/**
 * @param {string} name the package name
 * @param {string} entry the target path/import
 */
function toName(name, entry) {
	return entry === name ? '.'
		: entry[0] === '.' ? entry
		: entry.replace(new RegExp('^' + name + '\/'), './');
}

/**
 * @param {object} pkg package.json contents
 * @param {string} [entry] entry name or import path
 * @param {object} [options]
 * @param {boolean} [options.browser]
 * @param {boolean} [options.require]
 * @param {string[]} [options.conditions]
 * @param {boolean} [options.unsafe]
 */
function resolve(pkg, entry='.', options={}) {
	let { name, exports } = pkg;

	if (exports) {
		let { browser, require, unsafe, conditions=[] } = options;

		let target = toName(name, entry);
		if (target[0] !== '.') target = './' + target;

		if (typeof exports === 'string') {
			return target === '.' ? exports : bail(name, target);
		}

		let allows = new Set(['default', ...conditions]);
		unsafe || allows.add(require ? 'require' : 'import');
		unsafe || allows.add(browser ? 'browser' : 'node');

		let key, tmp, isSingle=false;

		for (key in exports) {
			isSingle = key[0] !== '.';
			break;
		}

		if (isSingle) {
			return target === '.'
				? loop(exports, allows) || bail(name, target, 1)
				: bail(name, target);
		}

		if (tmp = exports[target]) {
			return loop(tmp, allows) || bail(name, target, 1);
		}

		for (key in exports) {
			tmp = key[key.length - 1];
			if (tmp === '/' && target.startsWith(key)) {
				return (tmp = loop(exports[key], allows))
					? (tmp + target.substring(key.length))
					: bail(name, target, 1);
			}
			if (tmp === '*' && target.startsWith(key.slice(0, -1))) {
				// do not trigger if no *content* to inject
				if (target.substring(key.length - 1).length > 0) {
					return (tmp = loop(exports[key], allows))
						? tmp.replace('*', target.substring(key.length - 1))
						: bail(name, target, 1);
				}
			}
		}

		return bail(name, target);
	}
}

const ArrayIsArray = Array.isArray;
const JSONStringify = JSON.stringify;
const ObjectGetOwnPropertyNames = Object.getOwnPropertyNames;
const ObjectPrototypeHasOwnProperty = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
const RegExpPrototypeExec = (obj, string) => RegExp.prototype.exec.call(obj, string);
const RegExpPrototypeSymbolReplace = (obj, ...rest) => RegExp.prototype[Symbol.replace].apply(obj, rest);
const StringPrototypeEndsWith = (str, ...rest) => String.prototype.endsWith.apply(str, rest);
const StringPrototypeIncludes = (str, ...rest) => String.prototype.includes.apply(str, rest);
const StringPrototypeLastIndexOf = (str, ...rest) => String.prototype.lastIndexOf.apply(str, rest);
const StringPrototypeIndexOf = (str, ...rest) => String.prototype.indexOf.apply(str, rest);
const StringPrototypeReplace = (str, ...rest) => String.prototype.replace.apply(str, rest);
const StringPrototypeSlice = (str, ...rest) => String.prototype.slice.apply(str, rest);
const StringPrototypeStartsWith = (str, ...rest) => String.prototype.startsWith.apply(str, rest);
const SafeMap = Map;
const JSONParse = JSON.parse;

function createErrorType(code, messageCreator, errorType) {
  return class extends errorType {
    constructor(...args) {
      super(messageCreator(...args));
      this.code = code;
      this.name = `${errorType.name} [${code}]`;
    }
  };
}
const ERR_PACKAGE_IMPORT_NOT_DEFINED = createErrorType(
  `ERR_PACKAGE_IMPORT_NOT_DEFINED`,
  (specifier, packagePath, base) => {
    return `Package import specifier "${specifier}" is not defined${packagePath ? ` in package ${packagePath}package.json` : ``} imported from ${base}`;
  },
  TypeError
);
const ERR_INVALID_MODULE_SPECIFIER = createErrorType(
  `ERR_INVALID_MODULE_SPECIFIER`,
  (request, reason, base = void 0) => {
    return `Invalid module "${request}" ${reason}${base ? ` imported from ${base}` : ``}`;
  },
  TypeError
);
const ERR_INVALID_PACKAGE_TARGET = createErrorType(
  `ERR_INVALID_PACKAGE_TARGET`,
  (pkgPath, key, target, isImport = false, base = void 0) => {
    const relError = typeof target === `string` && !isImport && target.length && !StringPrototypeStartsWith(target, `./`);
    if (key === `.`) {
      assert__default.default(isImport === false);
      return `Invalid "exports" main target ${JSONStringify(target)} defined in the package config ${pkgPath}package.json${base ? ` imported from ${base}` : ``}${relError ? `; targets must start with "./"` : ``}`;
    }
    return `Invalid "${isImport ? `imports` : `exports`}" target ${JSONStringify(
      target
    )} defined for '${key}' in the package config ${pkgPath}package.json${base ? ` imported from ${base}` : ``}${relError ? `; targets must start with "./"` : ``}`;
  },
  Error
);
const ERR_INVALID_PACKAGE_CONFIG = createErrorType(
  `ERR_INVALID_PACKAGE_CONFIG`,
  (path, base, message) => {
    return `Invalid package config ${path}${base ? ` while importing ${base}` : ``}${message ? `. ${message}` : ``}`;
  },
  Error
);

function filterOwnProperties(source, keys) {
  const filtered = /* @__PURE__ */ Object.create(null);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    if (ObjectPrototypeHasOwnProperty(source, key)) {
      filtered[key] = source[key];
    }
  }
  return filtered;
}

const packageJSONCache = new SafeMap();
function getPackageConfig(path, specifier, base, readFileSyncFn) {
  const existing = packageJSONCache.get(path);
  if (existing !== void 0) {
    return existing;
  }
  const source = readFileSyncFn(path);
  if (source === void 0) {
    const packageConfig2 = {
      pjsonPath: path,
      exists: false,
      main: void 0,
      name: void 0,
      type: "none",
      exports: void 0,
      imports: void 0
    };
    packageJSONCache.set(path, packageConfig2);
    return packageConfig2;
  }
  let packageJSON;
  try {
    packageJSON = JSONParse(source);
  } catch (error) {
    throw new ERR_INVALID_PACKAGE_CONFIG(
      path,
      (base ? `"${specifier}" from ` : "") + url.fileURLToPath(base || specifier),
      error.message
    );
  }
  let { imports, main, name, type } = filterOwnProperties(packageJSON, [
    "imports",
    "main",
    "name",
    "type"
  ]);
  const exports = ObjectPrototypeHasOwnProperty(packageJSON, "exports") ? packageJSON.exports : void 0;
  if (typeof imports !== "object" || imports === null) {
    imports = void 0;
  }
  if (typeof main !== "string") {
    main = void 0;
  }
  if (typeof name !== "string") {
    name = void 0;
  }
  if (type !== "module" && type !== "commonjs") {
    type = "none";
  }
  const packageConfig = {
    pjsonPath: path,
    exists: true,
    main,
    name,
    type,
    exports,
    imports
  };
  packageJSONCache.set(path, packageConfig);
  return packageConfig;
}
function getPackageScopeConfig(resolved, readFileSyncFn) {
  let packageJSONUrl = new URL("./package.json", resolved);
  while (true) {
    const packageJSONPath2 = packageJSONUrl.pathname;
    if (StringPrototypeEndsWith(packageJSONPath2, "node_modules/package.json")) {
      break;
    }
    const packageConfig2 = getPackageConfig(
      url.fileURLToPath(packageJSONUrl),
      resolved,
      void 0,
      readFileSyncFn
    );
    if (packageConfig2.exists) {
      return packageConfig2;
    }
    const lastPackageJSONUrl = packageJSONUrl;
    packageJSONUrl = new URL("../package.json", packageJSONUrl);
    if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname) {
      break;
    }
  }
  const packageJSONPath = url.fileURLToPath(packageJSONUrl);
  const packageConfig = {
    pjsonPath: packageJSONPath,
    exists: false,
    main: void 0,
    name: void 0,
    type: "none",
    exports: void 0,
    imports: void 0
  };
  packageJSONCache.set(packageJSONPath, packageConfig);
  return packageConfig;
}

/**
  @license
  Copyright Node.js contributors. All rights reserved.

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to
  deal in the Software without restriction, including without limitation the
  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
  sell copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
  IN THE SOFTWARE.
*/
function throwImportNotDefined(specifier, packageJSONUrl, base) {
  throw new ERR_PACKAGE_IMPORT_NOT_DEFINED(
    specifier,
    packageJSONUrl && url.fileURLToPath(new URL(".", packageJSONUrl)),
    url.fileURLToPath(base)
  );
}
function throwInvalidSubpath(subpath, packageJSONUrl, internal, base) {
  const reason = `request is not a valid subpath for the "${internal ? "imports" : "exports"}" resolution of ${url.fileURLToPath(packageJSONUrl)}`;
  throw new ERR_INVALID_MODULE_SPECIFIER(
    subpath,
    reason,
    base && url.fileURLToPath(base)
  );
}
function throwInvalidPackageTarget(subpath, target, packageJSONUrl, internal, base) {
  if (typeof target === "object" && target !== null) {
    target = JSONStringify(target, null, "");
  } else {
    target = `${target}`;
  }
  throw new ERR_INVALID_PACKAGE_TARGET(
    url.fileURLToPath(new URL(".", packageJSONUrl)),
    subpath,
    target,
    internal,
    base && url.fileURLToPath(base)
  );
}
const invalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i;
const patternRegEx = /\*/g;
function resolvePackageTargetString(target, subpath, match, packageJSONUrl, base, pattern, internal, conditions) {
  if (subpath !== "" && !pattern && target[target.length - 1] !== "/")
    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);
  if (!StringPrototypeStartsWith(target, "./")) {
    if (internal && !StringPrototypeStartsWith(target, "../") && !StringPrototypeStartsWith(target, "/")) {
      let isURL = false;
      try {
        new URL(target);
        isURL = true;
      } catch {
      }
      if (!isURL) {
        const exportTarget = pattern ? RegExpPrototypeSymbolReplace(patternRegEx, target, () => subpath) : target + subpath;
        return exportTarget;
      }
    }
    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);
  }
  if (RegExpPrototypeExec(
    invalidSegmentRegEx,
    StringPrototypeSlice(target, 2)
  ) !== null)
    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);
  const resolved = new URL(target, packageJSONUrl);
  const resolvedPath = resolved.pathname;
  const packagePath = new URL(".", packageJSONUrl).pathname;
  if (!StringPrototypeStartsWith(resolvedPath, packagePath))
    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);
  if (subpath === "")
    return resolved;
  if (RegExpPrototypeExec(invalidSegmentRegEx, subpath) !== null) {
    const request = pattern ? StringPrototypeReplace(match, "*", () => subpath) : match + subpath;
    throwInvalidSubpath(request, packageJSONUrl, internal, base);
  }
  if (pattern) {
    return new URL(
      RegExpPrototypeSymbolReplace(patternRegEx, resolved.href, () => subpath)
    );
  }
  return new URL(subpath, resolved);
}
function isArrayIndex(key) {
  const keyNum = +key;
  if (`${keyNum}` !== key)
    return false;
  return keyNum >= 0 && keyNum < 4294967295;
}
function resolvePackageTarget(packageJSONUrl, target, subpath, packageSubpath, base, pattern, internal, conditions) {
  if (typeof target === "string") {
    return resolvePackageTargetString(
      target,
      subpath,
      packageSubpath,
      packageJSONUrl,
      base,
      pattern,
      internal);
  } else if (ArrayIsArray(target)) {
    if (target.length === 0) {
      return null;
    }
    let lastException;
    for (let i = 0; i < target.length; i++) {
      const targetItem = target[i];
      let resolveResult;
      try {
        resolveResult = resolvePackageTarget(
          packageJSONUrl,
          targetItem,
          subpath,
          packageSubpath,
          base,
          pattern,
          internal,
          conditions
        );
      } catch (e) {
        lastException = e;
        if (e.code === "ERR_INVALID_PACKAGE_TARGET") {
          continue;
        }
        throw e;
      }
      if (resolveResult === void 0) {
        continue;
      }
      if (resolveResult === null) {
        lastException = null;
        continue;
      }
      return resolveResult;
    }
    if (lastException === void 0 || lastException === null)
      return lastException;
    throw lastException;
  } else if (typeof target === "object" && target !== null) {
    const keys = ObjectGetOwnPropertyNames(target);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if (isArrayIndex(key)) {
        throw new ERR_INVALID_PACKAGE_CONFIG(
          url.fileURLToPath(packageJSONUrl),
          base,
          '"exports" cannot contain numeric property keys.'
        );
      }
    }
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if (key === "default" || conditions.has(key)) {
        const conditionalTarget = target[key];
        const resolveResult = resolvePackageTarget(
          packageJSONUrl,
          conditionalTarget,
          subpath,
          packageSubpath,
          base,
          pattern,
          internal,
          conditions
        );
        if (resolveResult === void 0)
          continue;
        return resolveResult;
      }
    }
    return void 0;
  } else if (target === null) {
    return null;
  }
  throwInvalidPackageTarget(
    packageSubpath,
    target,
    packageJSONUrl,
    internal,
    base
  );
}
function patternKeyCompare(a, b) {
  const aPatternIndex = StringPrototypeIndexOf(a, "*");
  const bPatternIndex = StringPrototypeIndexOf(b, "*");
  const baseLenA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;
  const baseLenB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;
  if (baseLenA > baseLenB)
    return -1;
  if (baseLenB > baseLenA)
    return 1;
  if (aPatternIndex === -1)
    return 1;
  if (bPatternIndex === -1)
    return -1;
  if (a.length > b.length)
    return -1;
  if (b.length > a.length)
    return 1;
  return 0;
}
function packageImportsResolve({
  name,
  base,
  conditions,
  readFileSyncFn
}) {
  if (name === "#" || StringPrototypeStartsWith(name, "#/") || StringPrototypeEndsWith(name, "/")) {
    const reason = "is not a valid internal imports specifier name";
    throw new ERR_INVALID_MODULE_SPECIFIER(name, reason, url.fileURLToPath(base));
  }
  let packageJSONUrl;
  const packageConfig = getPackageScopeConfig(base, readFileSyncFn);
  if (packageConfig.exists) {
    packageJSONUrl = url.pathToFileURL(packageConfig.pjsonPath);
    const imports = packageConfig.imports;
    if (imports) {
      if (ObjectPrototypeHasOwnProperty(imports, name) && !StringPrototypeIncludes(name, "*")) {
        const resolveResult = resolvePackageTarget(
          packageJSONUrl,
          imports[name],
          "",
          name,
          base,
          false,
          true,
          conditions
        );
        if (resolveResult != null) {
          return resolveResult;
        }
      } else {
        let bestMatch = "";
        let bestMatchSubpath;
        const keys = ObjectGetOwnPropertyNames(imports);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const patternIndex = StringPrototypeIndexOf(key, "*");
          if (patternIndex !== -1 && StringPrototypeStartsWith(
            name,
            StringPrototypeSlice(key, 0, patternIndex)
          )) {
            const patternTrailer = StringPrototypeSlice(key, patternIndex + 1);
            if (name.length >= key.length && StringPrototypeEndsWith(name, patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && StringPrototypeLastIndexOf(key, "*") === patternIndex) {
              bestMatch = key;
              bestMatchSubpath = StringPrototypeSlice(
                name,
                patternIndex,
                name.length - patternTrailer.length
              );
            }
          }
        }
        if (bestMatch) {
          const target = imports[bestMatch];
          const resolveResult = resolvePackageTarget(
            packageJSONUrl,
            target,
            bestMatchSubpath,
            bestMatch,
            base,
            true,
            true,
            conditions
          );
          if (resolveResult != null) {
            return resolveResult;
          }
        }
      }
    }
  }
  throwImportNotDefined(name, packageJSONUrl, base);
}

var ErrorCode = /* @__PURE__ */ ((ErrorCode2) => {
  ErrorCode2["API_ERROR"] = `API_ERROR`;
  ErrorCode2["BUILTIN_NODE_RESOLUTION_FAILED"] = `BUILTIN_NODE_RESOLUTION_FAILED`;
  ErrorCode2["EXPORTS_RESOLUTION_FAILED"] = `EXPORTS_RESOLUTION_FAILED`;
  ErrorCode2["MISSING_DEPENDENCY"] = `MISSING_DEPENDENCY`;
  ErrorCode2["MISSING_PEER_DEPENDENCY"] = `MISSING_PEER_DEPENDENCY`;
  ErrorCode2["QUALIFIED_PATH_RESOLUTION_FAILED"] = `QUALIFIED_PATH_RESOLUTION_FAILED`;
  ErrorCode2["INTERNAL"] = `INTERNAL`;
  ErrorCode2["UNDECLARED_DEPENDENCY"] = `UNDECLARED_DEPENDENCY`;
  ErrorCode2["UNSUPPORTED"] = `UNSUPPORTED`;
  return ErrorCode2;
})(ErrorCode || {});
const MODULE_NOT_FOUND_ERRORS = /* @__PURE__ */ new Set([
  "BUILTIN_NODE_RESOLUTION_FAILED" /* BUILTIN_NODE_RESOLUTION_FAILED */,
  "MISSING_DEPENDENCY" /* MISSING_DEPENDENCY */,
  "MISSING_PEER_DEPENDENCY" /* MISSING_PEER_DEPENDENCY */,
  "QUALIFIED_PATH_RESOLUTION_FAILED" /* QUALIFIED_PATH_RESOLUTION_FAILED */,
  "UNDECLARED_DEPENDENCY" /* UNDECLARED_DEPENDENCY */
]);
function makeError(pnpCode, message, data = {}, code) {
  code ?? (code = MODULE_NOT_FOUND_ERRORS.has(pnpCode) ? `MODULE_NOT_FOUND` : pnpCode);
  const propertySpec = {
    configurable: true,
    writable: true,
    enumerable: false
  };
  return Object.defineProperties(new Error(message), {
    code: {
      ...propertySpec,
      value: code
    },
    pnpCode: {
      ...propertySpec,
      value: pnpCode
    },
    data: {
      ...propertySpec,
      value: data
    }
  });
}
function getPathForDisplay(p) {
  return npath.normalize(npath.fromPortablePath(p));
}

const flagSymbol = Symbol('arg flag');

class ArgError extends Error {
	constructor(msg, code) {
		super(msg);
		this.name = 'ArgError';
		this.code = code;

		Object.setPrototypeOf(this, ArgError.prototype);
	}
}

function arg(
	opts,
	{
		argv = process.argv.slice(2),
		permissive = false,
		stopAtPositional = false
	} = {}
) {
	if (!opts) {
		throw new ArgError(
			'argument specification object is required',
			'ARG_CONFIG_NO_SPEC'
		);
	}

	const result = { _: [] };

	const aliases = {};
	const handlers = {};

	for (const key of Object.keys(opts)) {
		if (!key) {
			throw new ArgError(
				'argument key cannot be an empty string',
				'ARG_CONFIG_EMPTY_KEY'
			);
		}

		if (key[0] !== '-') {
			throw new ArgError(
				`argument key must start with '-' but found: '${key}'`,
				'ARG_CONFIG_NONOPT_KEY'
			);
		}

		if (key.length === 1) {
			throw new ArgError(
				`argument key must have a name; singular '-' keys are not allowed: ${key}`,
				'ARG_CONFIG_NONAME_KEY'
			);
		}

		if (typeof opts[key] === 'string') {
			aliases[key] = opts[key];
			continue;
		}

		let type = opts[key];
		let isFlag = false;

		if (
			Array.isArray(type) &&
			type.length === 1 &&
			typeof type[0] === 'function'
		) {
			const [fn] = type;
			type = (value, name, prev = []) => {
				prev.push(fn(value, name, prev[prev.length - 1]));
				return prev;
			};
			isFlag = fn === Boolean || fn[flagSymbol] === true;
		} else if (typeof type === 'function') {
			isFlag = type === Boolean || type[flagSymbol] === true;
		} else {
			throw new ArgError(
				`type missing or not a function or valid array type: ${key}`,
				'ARG_CONFIG_VAD_TYPE'
			);
		}

		if (key[1] !== '-' && key.length > 2) {
			throw new ArgError(
				`short argument keys (with a single hyphen) must have only one character: ${key}`,
				'ARG_CONFIG_SHORTOPT_TOOLONG'
			);
		}

		handlers[key] = [type, isFlag];
	}

	for (let i = 0, len = argv.length; i < len; i++) {
		const wholeArg = argv[i];

		if (stopAtPositional && result._.length > 0) {
			result._ = result._.concat(argv.slice(i));
			break;
		}

		if (wholeArg === '--') {
			result._ = result._.concat(argv.slice(i + 1));
			break;
		}

		if (wholeArg.length > 1 && wholeArg[0] === '-') {
			/* eslint-disable operator-linebreak */
			const separatedArguments =
				wholeArg[1] === '-' || wholeArg.length === 2
					? [wholeArg]
					: wholeArg
							.slice(1)
							.split('')
							.map((a) => `-${a}`);
			/* eslint-enable operator-linebreak */

			for (let j = 0; j < separatedArguments.length; j++) {
				const arg = separatedArguments[j];
				const [originalArgName, argStr] =
					arg[1] === '-' ? arg.split(/=(.*)/, 2) : [arg, undefined];

				let argName = originalArgName;
				while (argName in aliases) {
					argName = aliases[argName];
				}

				if (!(argName in handlers)) {
					if (permissive) {
						result._.push(arg);
						continue;
					} else {
						throw new ArgError(
							`unknown or unexpected option: ${originalArgName}`,
							'ARG_UNKNOWN_OPTION'
						);
					}
				}

				const [type, isFlag] = handlers[argName];

				if (!isFlag && j + 1 < separatedArguments.length) {
					throw new ArgError(
						`option requires argument (but was followed by another short argument): ${originalArgName}`,
						'ARG_MISSING_REQUIRED_SHORTARG'
					);
				}

				if (isFlag) {
					result[argName] = type(true, argName, result[argName]);
				} else if (argStr === undefined) {
					if (
						argv.length < i + 2 ||
						(argv[i + 1].length > 1 &&
							argv[i + 1][0] === '-' &&
							!(
								argv[i + 1].match(/^-?\d*(\.(?=\d))?\d*$/) &&
								(type === Number ||
									// eslint-disable-next-line no-undef
									(typeof BigInt !== 'undefined' && type === BigInt))
							))
					) {
						const extended =
							originalArgName === argName ? '' : ` (alias for ${argName})`;
						throw new ArgError(
							`option requires argument: ${originalArgName}${extended}`,
							'ARG_MISSING_REQUIRED_LONGARG'
						);
					}

					result[argName] = type(argv[i + 1], argName, result[argName]);
					++i;
				} else {
					result[argName] = type(argStr, argName, result[argName]);
				}
			}
		} else {
			result._.push(wholeArg);
		}
	}

	return result;
}

arg.flag = (fn) => {
	fn[flagSymbol] = true;
	return fn;
};

// Utility types
arg.COUNT = arg.flag((v, name, existingCount) => (existingCount || 0) + 1);

// Expose error class
arg.ArgError = ArgError;

var arg_1 = arg;

/**
  @license
  The MIT License (MIT)

  Copyright (c) 2014 Blake Embrey (hello@blakeembrey.com)

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
*/
function getOptionValue(opt) {
  parseOptions();
  return options[opt];
}
let options;
function parseOptions() {
  if (!options) {
    options = {
      "--conditions": [],
      ...parseArgv(getNodeOptionsEnvArgv()),
      ...parseArgv(process.execArgv)
    };
  }
}
function parseArgv(argv) {
  return arg_1(
    {
      "--conditions": [String],
      "-C": "--conditions"
    },
    {
      argv,
      permissive: true
    }
  );
}
function getNodeOptionsEnvArgv() {
  const errors = [];
  const envArgv = ParseNodeOptionsEnvVar(process.env.NODE_OPTIONS || "", errors);
  if (errors.length !== 0) ;
  return envArgv;
}
function ParseNodeOptionsEnvVar(node_options, errors) {
  const env_argv = [];
  let is_in_string = false;
  let will_start_new_arg = true;
  for (let index = 0; index < node_options.length; ++index) {
    let c = node_options[index];
    if (c === "\\" && is_in_string) {
      if (index + 1 === node_options.length) {
        errors.push("invalid value for NODE_OPTIONS (invalid escape)\n");
        return env_argv;
      } else {
        c = node_options[++index];
      }
    } else if (c === " " && !is_in_string) {
      will_start_new_arg = true;
      continue;
    } else if (c === '"') {
      is_in_string = !is_in_string;
      continue;
    }
    if (will_start_new_arg) {
      env_argv.push(c);
      will_start_new_arg = false;
    } else {
      env_argv[env_argv.length - 1] += c;
    }
  }
  if (is_in_string) {
    errors.push("invalid value for NODE_OPTIONS (unterminated string)\n");
  }
  return env_argv;
}

const [major, minor] = process.versions.node.split(`.`).map((value) => parseInt(value, 10));
const WATCH_MODE_MESSAGE_USES_ARRAYS = major > 19 || major === 19 && minor >= 2 || major === 18 && minor >= 13;

const builtinModules = new Set(module$1.Module.builtinModules || Object.keys(process.binding(`natives`)));
const isBuiltinModule = (request) => request.startsWith(`node:`) || builtinModules.has(request);
function reportRequiredFilesToWatchMode(files) {
  if (process.env.WATCH_REPORT_DEPENDENCIES && process.send) {
    files = files.map((filename) => npath.fromPortablePath(VirtualFS.resolveVirtual(npath.toPortablePath(filename))));
    if (WATCH_MODE_MESSAGE_USES_ARRAYS) {
      process.send({ "watch:require": files });
    } else {
      for (const filename of files) {
        process.send({ "watch:require": filename });
      }
    }
  }
}

function makeApi(runtimeState, opts) {
  const alwaysWarnOnFallback = Number(process.env.PNP_ALWAYS_WARN_ON_FALLBACK) > 0;
  const debugLevel = Number(process.env.PNP_DEBUG_LEVEL);
  const pathRegExp = /^(?![a-zA-Z]:[\\/]|\\\\|\.{0,2}(?:\/|$))((?:node:)?(?:@[^/]+\/)?[^/]+)\/*(.*|)$/;
  const isStrictRegExp = /^(\/|\.{1,2}(\/|$))/;
  const isDirRegExp = /\/$/;
  const isRelativeRegexp = /^\.{0,2}\//;
  const topLevelLocator = { name: null, reference: null };
  const fallbackLocators = [];
  const emittedWarnings = /* @__PURE__ */ new Set();
  if (runtimeState.enableTopLevelFallback === true)
    fallbackLocators.push(topLevelLocator);
  if (opts.compatibilityMode !== false) {
    for (const name of [`react-scripts`, `gatsby`]) {
      const packageStore = runtimeState.packageRegistry.get(name);
      if (packageStore) {
        for (const reference of packageStore.keys()) {
          if (reference === null) {
            throw new Error(`Assertion failed: This reference shouldn't be null`);
          } else {
            fallbackLocators.push({ name, reference });
          }
        }
      }
    }
  }
  const {
    ignorePattern,
    packageRegistry,
    packageLocatorsByLocations
  } = runtimeState;
  function makeLogEntry(name, args) {
    return {
      fn: name,
      args,
      error: null,
      result: null
    };
  }
  function trace(entry) {
    var _a, _b, _c, _d;
    const colors = ((_b = (_a = process.stderr) == null ? void 0 : _a.hasColors) == null ? void 0 : _b.call(_a)) ?? process.stdout.isTTY;
    const c = (n, str) => `\x1B[${n}m${str}\x1B[0m`;
    const error = entry.error;
    if (error)
      console.error(c(`31;1`, `\u2716 ${(_c = entry.error) == null ? void 0 : _c.message.replace(/\n.*/s, ``)}`));
    else
      console.error(c(`33;1`, `\u203C Resolution`));
    if (entry.args.length > 0)
      console.error();
    for (const arg of entry.args)
      console.error(`  ${c(`37;1`, `In \u2190`)} ${nodeUtils.inspect(arg, { colors, compact: true })}`);
    if (entry.result) {
      console.error();
      console.error(`  ${c(`37;1`, `Out \u2192`)} ${nodeUtils.inspect(entry.result, { colors, compact: true })}`);
    }
    const stack = ((_d = new Error().stack.match(/(?<=^ +)at.*/gm)) == null ? void 0 : _d.slice(2)) ?? [];
    if (stack.length > 0) {
      console.error();
      for (const line of stack) {
        console.error(`  ${c(`38;5;244`, line)}`);
      }
    }
    console.error();
  }
  function maybeLog(name, fn) {
    if (opts.allowDebug === false)
      return fn;
    if (Number.isFinite(debugLevel)) {
      if (debugLevel >= 2) {
        return (...args) => {
          const logEntry = makeLogEntry(name, args);
          try {
            return logEntry.result = fn(...args);
          } catch (error) {
            throw logEntry.error = error;
          } finally {
            trace(logEntry);
          }
        };
      } else if (debugLevel >= 1) {
        return (...args) => {
          try {
            return fn(...args);
          } catch (error) {
            const logEntry = makeLogEntry(name, args);
            logEntry.error = error;
            trace(logEntry);
            throw error;
          }
        };
      }
    }
    return fn;
  }
  function getPackageInformationSafe(packageLocator) {
    const packageInformation = getPackageInformation(packageLocator);
    if (!packageInformation) {
      throw makeError(
        ErrorCode.INTERNAL,
        `Couldn't find a matching entry in the dependency tree for the specified parent (this is probably an internal error)`
      );
    }
    return packageInformation;
  }
  function isDependencyTreeRoot(packageLocator) {
    if (packageLocator.name === null)
      return true;
    for (const dependencyTreeRoot of runtimeState.dependencyTreeRoots)
      if (dependencyTreeRoot.name === packageLocator.name && dependencyTreeRoot.reference === packageLocator.reference)
        return true;
    return false;
  }
  const defaultExportsConditions = /* @__PURE__ */ new Set([
    `default`,
    `node`,
    `require`,
    ...getOptionValue(`--conditions`)
  ]);
  function applyNodeExportsResolution(unqualifiedPath, conditions = defaultExportsConditions) {
    const locator = findPackageLocator(ppath.join(unqualifiedPath, `internal.js`), {
      resolveIgnored: true,
      includeDiscardFromLookup: true
    });
    if (locator === null) {
      throw makeError(
        ErrorCode.INTERNAL,
        `The locator that owns the "${unqualifiedPath}" path can't be found inside the dependency tree (this is probably an internal error)`
      );
    }
    const { packageLocation } = getPackageInformationSafe(locator);
    const manifestPath = ppath.join(packageLocation, Filename.manifest);
    if (!opts.fakeFs.existsSync(manifestPath))
      return null;
    const pkgJson = JSON.parse(opts.fakeFs.readFileSync(manifestPath, `utf8`));
    let subpath = ppath.contains(packageLocation, unqualifiedPath);
    if (subpath === null) {
      throw makeError(
        ErrorCode.INTERNAL,
        `unqualifiedPath doesn't contain the packageLocation (this is probably an internal error)`
      );
    }
    if (!isRelativeRegexp.test(subpath))
      subpath = `./${subpath}`;
    let resolvedExport;
    try {
      resolvedExport = resolve(pkgJson, ppath.normalize(subpath), {
        conditions,
        unsafe: true
      });
    } catch (error) {
      throw makeError(
        ErrorCode.EXPORTS_RESOLUTION_FAILED,
        error.message,
        { unqualifiedPath: getPathForDisplay(unqualifiedPath), locator, pkgJson, subpath: getPathForDisplay(subpath), conditions },
        `ERR_PACKAGE_PATH_NOT_EXPORTED`
      );
    }
    if (typeof resolvedExport === `string`)
      return ppath.join(packageLocation, resolvedExport);
    return null;
  }
  function applyNodeExtensionResolution(unqualifiedPath, candidates, { extensions }) {
    let stat;
    try {
      candidates.push(unqualifiedPath);
      stat = opts.fakeFs.statSync(unqualifiedPath);
    } catch (error) {
    }
    if (stat && !stat.isDirectory())
      return opts.fakeFs.realpathSync(unqualifiedPath);
    if (stat && stat.isDirectory()) {
      let pkgJson;
      try {
        pkgJson = JSON.parse(opts.fakeFs.readFileSync(ppath.join(unqualifiedPath, Filename.manifest), `utf8`));
      } catch (error) {
      }
      let nextUnqualifiedPath;
      if (pkgJson && pkgJson.main)
        nextUnqualifiedPath = ppath.resolve(unqualifiedPath, pkgJson.main);
      if (nextUnqualifiedPath && nextUnqualifiedPath !== unqualifiedPath) {
        const resolution = applyNodeExtensionResolution(nextUnqualifiedPath, candidates, { extensions });
        if (resolution !== null) {
          return resolution;
        }
      }
    }
    for (let i = 0, length = extensions.length; i < length; i++) {
      const candidateFile = `${unqualifiedPath}${extensions[i]}`;
      candidates.push(candidateFile);
      if (opts.fakeFs.existsSync(candidateFile)) {
        return candidateFile;
      }
    }
    if (stat && stat.isDirectory()) {
      for (let i = 0, length = extensions.length; i < length; i++) {
        const candidateFile = ppath.format({ dir: unqualifiedPath, name: `index`, ext: extensions[i] });
        candidates.push(candidateFile);
        if (opts.fakeFs.existsSync(candidateFile)) {
          return candidateFile;
        }
      }
    }
    return null;
  }
  function makeFakeModule(path) {
    const fakeModule = new module$1.Module(path, null);
    fakeModule.filename = path;
    fakeModule.paths = module$1.Module._nodeModulePaths(path);
    return fakeModule;
  }
  function callNativeResolution(request, issuer) {
    if (issuer.endsWith(`/`))
      issuer = ppath.join(issuer, `internal.js`);
    return module$1.Module._resolveFilename(npath.fromPortablePath(request), makeFakeModule(npath.fromPortablePath(issuer)), false, { plugnplay: false });
  }
  function isPathIgnored(path) {
    if (ignorePattern === null)
      return false;
    const subPath = ppath.contains(runtimeState.basePath, path);
    if (subPath === null)
      return false;
    if (ignorePattern.test(subPath.replace(/\/$/, ``))) {
      return true;
    } else {
      return false;
    }
  }
  const VERSIONS = { std: 3, resolveVirtual: 1, getAllLocators: 1 };
  const topLevel = topLevelLocator;
  function getPackageInformation({ name, reference }) {
    const packageInformationStore = packageRegistry.get(name);
    if (!packageInformationStore)
      return null;
    const packageInformation = packageInformationStore.get(reference);
    if (!packageInformation)
      return null;
    return packageInformation;
  }
  function findPackageDependents({ name, reference }) {
    const dependents = [];
    for (const [dependentName, packageInformationStore] of packageRegistry) {
      if (dependentName === null)
        continue;
      for (const [dependentReference, packageInformation] of packageInformationStore) {
        if (dependentReference === null)
          continue;
        const dependencyReference = packageInformation.packageDependencies.get(name);
        if (dependencyReference !== reference)
          continue;
        if (dependentName === name && dependentReference === reference)
          continue;
        dependents.push({
          name: dependentName,
          reference: dependentReference
        });
      }
    }
    return dependents;
  }
  function findBrokenPeerDependencies(dependency, initialPackage) {
    const brokenPackages = /* @__PURE__ */ new Map();
    const alreadyVisited = /* @__PURE__ */ new Set();
    const traversal = (currentPackage) => {
      const identifier = JSON.stringify(currentPackage.name);
      if (alreadyVisited.has(identifier))
        return;
      alreadyVisited.add(identifier);
      const dependents = findPackageDependents(currentPackage);
      for (const dependent of dependents) {
        const dependentInformation = getPackageInformationSafe(dependent);
        if (dependentInformation.packagePeers.has(dependency)) {
          traversal(dependent);
        } else {
          let brokenSet = brokenPackages.get(dependent.name);
          if (typeof brokenSet === `undefined`)
            brokenPackages.set(dependent.name, brokenSet = /* @__PURE__ */ new Set());
          brokenSet.add(dependent.reference);
        }
      }
    };
    traversal(initialPackage);
    const brokenList = [];
    for (const name of [...brokenPackages.keys()].sort())
      for (const reference of [...brokenPackages.get(name)].sort())
        brokenList.push({ name, reference });
    return brokenList;
  }
  function findPackageLocator(location, { resolveIgnored = false, includeDiscardFromLookup = false } = {}) {
    if (isPathIgnored(location) && !resolveIgnored)
      return null;
    let relativeLocation = ppath.relative(runtimeState.basePath, location);
    if (!relativeLocation.match(isStrictRegExp))
      relativeLocation = `./${relativeLocation}`;
    if (!relativeLocation.endsWith(`/`))
      relativeLocation = `${relativeLocation}/`;
    do {
      const entry = packageLocatorsByLocations.get(relativeLocation);
      if (typeof entry === `undefined` || entry.discardFromLookup && !includeDiscardFromLookup) {
        relativeLocation = relativeLocation.substring(0, relativeLocation.lastIndexOf(`/`, relativeLocation.length - 2) + 1);
        continue;
      }
      return entry.locator;
    } while (relativeLocation !== ``);
    return null;
  }
  function tryReadFile(filePath) {
    try {
      return opts.fakeFs.readFileSync(npath.toPortablePath(filePath), `utf8`);
    } catch (err) {
      if (err.code === `ENOENT`)
        return void 0;
      throw err;
    }
  }
  function resolveToUnqualified(request, issuer, { considerBuiltins = true } = {}) {
    if (request.startsWith(`#`))
      throw new Error(`resolveToUnqualified can not handle private import mappings`);
    if (request === `pnpapi`)
      return npath.toPortablePath(opts.pnpapiResolution);
    if (considerBuiltins && isBuiltinModule(request))
      return null;
    const requestForDisplay = getPathForDisplay(request);
    const issuerForDisplay = issuer && getPathForDisplay(issuer);
    if (issuer && isPathIgnored(issuer)) {
      if (!ppath.isAbsolute(request) || findPackageLocator(request) === null) {
        const result = callNativeResolution(request, issuer);
        if (result === false) {
          throw makeError(
            ErrorCode.BUILTIN_NODE_RESOLUTION_FAILED,
            `The builtin node resolution algorithm was unable to resolve the requested module (it didn't go through the pnp resolver because the issuer was explicitely ignored by the regexp)

Require request: "${requestForDisplay}"
Required by: ${issuerForDisplay}
`,
            { request: requestForDisplay, issuer: issuerForDisplay }
          );
        }
        return npath.toPortablePath(result);
      }
    }
    let unqualifiedPath;
    const dependencyNameMatch = request.match(pathRegExp);
    if (!dependencyNameMatch) {
      if (ppath.isAbsolute(request)) {
        unqualifiedPath = ppath.normalize(request);
      } else {
        if (!issuer) {
          throw makeError(
            ErrorCode.API_ERROR,
            `The resolveToUnqualified function must be called with a valid issuer when the path isn't a builtin nor absolute`,
            { request: requestForDisplay, issuer: issuerForDisplay }
          );
        }
        const absoluteIssuer = ppath.resolve(issuer);
        if (issuer.match(isDirRegExp)) {
          unqualifiedPath = ppath.normalize(ppath.join(absoluteIssuer, request));
        } else {
          unqualifiedPath = ppath.normalize(ppath.join(ppath.dirname(absoluteIssuer), request));
        }
      }
    } else {
      if (!issuer) {
        throw makeError(
          ErrorCode.API_ERROR,
          `The resolveToUnqualified function must be called with a valid issuer when the path isn't a builtin nor absolute`,
          { request: requestForDisplay, issuer: issuerForDisplay }
        );
      }
      const [, dependencyName, subPath] = dependencyNameMatch;
      const issuerLocator = findPackageLocator(issuer);
      if (!issuerLocator) {
        const result = callNativeResolution(request, issuer);
        if (result === false) {
          throw makeError(
            ErrorCode.BUILTIN_NODE_RESOLUTION_FAILED,
            `The builtin node resolution algorithm was unable to resolve the requested module (it didn't go through the pnp resolver because the issuer doesn't seem to be part of the Yarn-managed dependency tree).

Require path: "${requestForDisplay}"
Required by: ${issuerForDisplay}
`,
            { request: requestForDisplay, issuer: issuerForDisplay }
          );
        }
        return npath.toPortablePath(result);
      }
      const issuerInformation = getPackageInformationSafe(issuerLocator);
      let dependencyReference = issuerInformation.packageDependencies.get(dependencyName);
      let fallbackReference = null;
      if (dependencyReference == null) {
        if (issuerLocator.name !== null) {
          const exclusionEntry = runtimeState.fallbackExclusionList.get(issuerLocator.name);
          const canUseFallbacks = !exclusionEntry || !exclusionEntry.has(issuerLocator.reference);
          if (canUseFallbacks) {
            for (let t = 0, T = fallbackLocators.length; t < T; ++t) {
              const fallbackInformation = getPackageInformationSafe(fallbackLocators[t]);
              const reference = fallbackInformation.packageDependencies.get(dependencyName);
              if (reference == null)
                continue;
              if (alwaysWarnOnFallback)
                fallbackReference = reference;
              else
                dependencyReference = reference;
              break;
            }
            if (runtimeState.enableTopLevelFallback) {
              if (dependencyReference == null && fallbackReference === null) {
                const reference = runtimeState.fallbackPool.get(dependencyName);
                if (reference != null) {
                  fallbackReference = reference;
                }
              }
            }
          }
        }
      }
      let error = null;
      if (dependencyReference === null) {
        if (isDependencyTreeRoot(issuerLocator)) {
          error = makeError(
            ErrorCode.MISSING_PEER_DEPENDENCY,
            `Your application tried to access ${dependencyName} (a peer dependency); this isn't allowed as there is no ancestor to satisfy the requirement. Use a devDependency if needed.

Required package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerForDisplay}
`,
            { request: requestForDisplay, issuer: issuerForDisplay, dependencyName }
          );
        } else {
          const brokenAncestors = findBrokenPeerDependencies(dependencyName, issuerLocator);
          if (brokenAncestors.every((ancestor) => isDependencyTreeRoot(ancestor))) {
            error = makeError(
              ErrorCode.MISSING_PEER_DEPENDENCY,
              `${issuerLocator.name} tried to access ${dependencyName} (a peer dependency) but it isn't provided by your application; this makes the require call ambiguous and unsound.

Required package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerLocator.name}@${issuerLocator.reference} (via ${issuerForDisplay})
${brokenAncestors.map((ancestorLocator) => `Ancestor breaking the chain: ${ancestorLocator.name}@${ancestorLocator.reference}
`).join(``)}
`,
              { request: requestForDisplay, issuer: issuerForDisplay, issuerLocator: Object.assign({}, issuerLocator), dependencyName, brokenAncestors }
            );
          } else {
            error = makeError(
              ErrorCode.MISSING_PEER_DEPENDENCY,
              `${issuerLocator.name} tried to access ${dependencyName} (a peer dependency) but it isn't provided by its ancestors; this makes the require call ambiguous and unsound.

Required package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerLocator.name}@${issuerLocator.reference} (via ${issuerForDisplay})

${brokenAncestors.map((ancestorLocator) => `Ancestor breaking the chain: ${ancestorLocator.name}@${ancestorLocator.reference}
`).join(``)}
`,
              { request: requestForDisplay, issuer: issuerForDisplay, issuerLocator: Object.assign({}, issuerLocator), dependencyName, brokenAncestors }
            );
          }
        }
      } else if (dependencyReference === void 0) {
        if (!considerBuiltins && isBuiltinModule(request)) {
          if (isDependencyTreeRoot(issuerLocator)) {
            error = makeError(
              ErrorCode.UNDECLARED_DEPENDENCY,
              `Your application tried to access ${dependencyName}. While this module is usually interpreted as a Node builtin, your resolver is running inside a non-Node resolution context where such builtins are ignored. Since ${dependencyName} isn't otherwise declared in your dependencies, this makes the require call ambiguous and unsound.

Required package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerForDisplay}
`,
              { request: requestForDisplay, issuer: issuerForDisplay, dependencyName }
            );
          } else {
            error = makeError(
              ErrorCode.UNDECLARED_DEPENDENCY,
              `${issuerLocator.name} tried to access ${dependencyName}. While this module is usually interpreted as a Node builtin, your resolver is running inside a non-Node resolution context where such builtins are ignored. Since ${dependencyName} isn't otherwise declared in ${issuerLocator.name}'s dependencies, this makes the require call ambiguous and unsound.

Required package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerForDisplay}
`,
              { request: requestForDisplay, issuer: issuerForDisplay, issuerLocator: Object.assign({}, issuerLocator), dependencyName }
            );
          }
        } else {
          if (isDependencyTreeRoot(issuerLocator)) {
            error = makeError(
              ErrorCode.UNDECLARED_DEPENDENCY,
              `Your application tried to access ${dependencyName}, but it isn't declared in your dependencies; this makes the require call ambiguous and unsound.

Required package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerForDisplay}
`,
              { request: requestForDisplay, issuer: issuerForDisplay, dependencyName }
            );
          } else {
            error = makeError(
              ErrorCode.UNDECLARED_DEPENDENCY,
              `${issuerLocator.name} tried to access ${dependencyName}, but it isn't declared in its dependencies; this makes the require call ambiguous and unsound.

Required package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerLocator.name}@${issuerLocator.reference} (via ${issuerForDisplay})
`,
              { request: requestForDisplay, issuer: issuerForDisplay, issuerLocator: Object.assign({}, issuerLocator), dependencyName }
            );
          }
        }
      }
      if (dependencyReference == null) {
        if (fallbackReference === null || error === null)
          throw error || new Error(`Assertion failed: Expected an error to have been set`);
        dependencyReference = fallbackReference;
        const message = error.message.replace(/\n.*/g, ``);
        error.message = message;
        if (!emittedWarnings.has(message) && debugLevel !== 0) {
          emittedWarnings.add(message);
          process.emitWarning(error);
        }
      }
      const dependencyLocator = Array.isArray(dependencyReference) ? { name: dependencyReference[0], reference: dependencyReference[1] } : { name: dependencyName, reference: dependencyReference };
      const dependencyInformation = getPackageInformationSafe(dependencyLocator);
      if (!dependencyInformation.packageLocation) {
        throw makeError(
          ErrorCode.MISSING_DEPENDENCY,
          `A dependency seems valid but didn't get installed for some reason. This might be caused by a partial install, such as dev vs prod.

Required package: ${dependencyLocator.name}@${dependencyLocator.reference}${dependencyLocator.name !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerLocator.name}@${issuerLocator.reference} (via ${issuerForDisplay})
`,
          { request: requestForDisplay, issuer: issuerForDisplay, dependencyLocator: Object.assign({}, dependencyLocator) }
        );
      }
      const dependencyLocation = dependencyInformation.packageLocation;
      if (subPath) {
        unqualifiedPath = ppath.join(dependencyLocation, subPath);
      } else {
        unqualifiedPath = dependencyLocation;
      }
    }
    return ppath.normalize(unqualifiedPath);
  }
  function resolveUnqualifiedExport(request, unqualifiedPath, conditions = defaultExportsConditions) {
    if (isStrictRegExp.test(request))
      return unqualifiedPath;
    const unqualifiedExportPath = applyNodeExportsResolution(unqualifiedPath, conditions);
    if (unqualifiedExportPath) {
      return ppath.normalize(unqualifiedExportPath);
    } else {
      return unqualifiedPath;
    }
  }
  function resolveUnqualified(unqualifiedPath, { extensions = Object.keys(module$1.Module._extensions) } = {}) {
    const candidates = [];
    const qualifiedPath = applyNodeExtensionResolution(unqualifiedPath, candidates, { extensions });
    if (qualifiedPath) {
      return ppath.normalize(qualifiedPath);
    } else {
      reportRequiredFilesToWatchMode(candidates.map((candidate) => npath.fromPortablePath(candidate)));
      const unqualifiedPathForDisplay = getPathForDisplay(unqualifiedPath);
      const containingPackage = findPackageLocator(unqualifiedPath);
      if (containingPackage) {
        const { packageLocation } = getPackageInformationSafe(containingPackage);
        let exists = true;
        try {
          opts.fakeFs.accessSync(packageLocation);
        } catch (err) {
          if ((err == null ? void 0 : err.code) === `ENOENT`) {
            exists = false;
          } else {
            const readableError = ((err == null ? void 0 : err.message) ?? err ?? `empty exception thrown`).replace(/^[A-Z]/, ($0) => $0.toLowerCase());
            throw makeError(ErrorCode.QUALIFIED_PATH_RESOLUTION_FAILED, `Required package exists but could not be accessed (${readableError}).

Missing package: ${containingPackage.name}@${containingPackage.reference}
Expected package location: ${getPathForDisplay(packageLocation)}
`, { unqualifiedPath: unqualifiedPathForDisplay, extensions });
          }
        }
        if (!exists) {
          const errorMessage = packageLocation.includes(`/unplugged/`) ? `Required unplugged package missing from disk. This may happen when switching branches without running installs (unplugged packages must be fully materialized on disk to work).` : `Required package missing from disk. If you keep your packages inside your repository then restarting the Node process may be enough. Otherwise, try to run an install first.`;
          throw makeError(
            ErrorCode.QUALIFIED_PATH_RESOLUTION_FAILED,
            `${errorMessage}

Missing package: ${containingPackage.name}@${containingPackage.reference}
Expected package location: ${getPathForDisplay(packageLocation)}
`,
            { unqualifiedPath: unqualifiedPathForDisplay, extensions }
          );
        }
      }
      throw makeError(
        ErrorCode.QUALIFIED_PATH_RESOLUTION_FAILED,
        `Qualified path resolution failed: we looked for the following paths, but none could be accessed.

Source path: ${unqualifiedPathForDisplay}
${candidates.map((candidate) => `Not found: ${getPathForDisplay(candidate)}
`).join(``)}`,
        { unqualifiedPath: unqualifiedPathForDisplay, extensions }
      );
    }
  }
  function resolvePrivateRequest(request, issuer, opts2) {
    if (!issuer)
      throw new Error(`Assertion failed: An issuer is required to resolve private import mappings`);
    const resolved = packageImportsResolve({
      name: request,
      base: url.pathToFileURL(npath.fromPortablePath(issuer)),
      conditions: opts2.conditions ?? defaultExportsConditions,
      readFileSyncFn: tryReadFile
    });
    if (resolved instanceof URL) {
      return resolveUnqualified(npath.toPortablePath(url.fileURLToPath(resolved)), { extensions: opts2.extensions });
    } else {
      if (resolved.startsWith(`#`))
        throw new Error(`Mapping from one private import to another isn't allowed`);
      return resolveRequest(resolved, issuer, opts2);
    }
  }
  function resolveRequest(request, issuer, opts2 = {}) {
    try {
      if (request.startsWith(`#`))
        return resolvePrivateRequest(request, issuer, opts2);
      const { considerBuiltins, extensions, conditions } = opts2;
      const unqualifiedPath = resolveToUnqualified(request, issuer, { considerBuiltins });
      if (request === `pnpapi`)
        return unqualifiedPath;
      if (unqualifiedPath === null)
        return null;
      const isIssuerIgnored = () => issuer !== null ? isPathIgnored(issuer) : false;
      const remappedPath = (!considerBuiltins || !isBuiltinModule(request)) && !isIssuerIgnored() ? resolveUnqualifiedExport(request, unqualifiedPath, conditions) : unqualifiedPath;
      return resolveUnqualified(remappedPath, { extensions });
    } catch (error) {
      if (Object.prototype.hasOwnProperty.call(error, `pnpCode`))
        Object.assign(error.data, { request: getPathForDisplay(request), issuer: issuer && getPathForDisplay(issuer) });
      throw error;
    }
  }
  function resolveVirtual(request) {
    const normalized = ppath.normalize(request);
    const resolved = VirtualFS.resolveVirtual(normalized);
    return resolved !== normalized ? resolved : null;
  }
  return {
    VERSIONS,
    topLevel,
    getLocator: (name, referencish) => {
      if (Array.isArray(referencish)) {
        return { name: referencish[0], reference: referencish[1] };
      } else {
        return { name, reference: referencish };
      }
    },
    getDependencyTreeRoots: () => {
      return [...runtimeState.dependencyTreeRoots];
    },
    getAllLocators() {
      const locators = [];
      for (const [name, entry] of packageRegistry)
        for (const reference of entry.keys())
          if (name !== null && reference !== null)
            locators.push({ name, reference });
      return locators;
    },
    getPackageInformation: (locator) => {
      const info = getPackageInformation(locator);
      if (info === null)
        return null;
      const packageLocation = npath.fromPortablePath(info.packageLocation);
      const nativeInfo = { ...info, packageLocation };
      return nativeInfo;
    },
    findPackageLocator: (path) => {
      return findPackageLocator(npath.toPortablePath(path));
    },
    resolveToUnqualified: maybeLog(`resolveToUnqualified`, (request, issuer, opts2) => {
      const portableIssuer = issuer !== null ? npath.toPortablePath(issuer) : null;
      const resolution = resolveToUnqualified(npath.toPortablePath(request), portableIssuer, opts2);
      if (resolution === null)
        return null;
      return npath.fromPortablePath(resolution);
    }),
    resolveUnqualified: maybeLog(`resolveUnqualified`, (unqualifiedPath, opts2) => {
      return npath.fromPortablePath(resolveUnqualified(npath.toPortablePath(unqualifiedPath), opts2));
    }),
    resolveRequest: maybeLog(`resolveRequest`, (request, issuer, opts2) => {
      const portableIssuer = issuer !== null ? npath.toPortablePath(issuer) : null;
      const resolution = resolveRequest(npath.toPortablePath(request), portableIssuer, opts2);
      if (resolution === null)
        return null;
      return npath.fromPortablePath(resolution);
    }),
    resolveVirtual: maybeLog(`resolveVirtual`, (path) => {
      const result = resolveVirtual(npath.toPortablePath(path));
      if (result !== null) {
        return npath.fromPortablePath(result);
      } else {
        return null;
      }
    })
  };
}

async function hydratePnpFile(location, { fakeFs, pnpapiResolution }) {
  const source = await fakeFs.readFilePromise(location, `utf8`);
  return hydratePnpSource(source, {
    basePath: path.dirname(location),
    fakeFs,
    pnpapiResolution
  });
}
function hydratePnpSource(source, { basePath, fakeFs, pnpapiResolution }) {
  const data = JSON.parse(source);
  const runtimeState = hydrateRuntimeState(data, {
    basePath
  });
  return makeApi(runtimeState, {
    compatibilityMode: true,
    fakeFs,
    pnpapiResolution
  });
}

const makeRuntimeApi = (settings, basePath, fakeFs) => {
  const data = generateSerializedState(settings);
  const state = hydrateRuntimeState(data, { basePath });
  const pnpapiResolution = npath.join(basePath, Filename.pnpCjs);
  return makeApi(state, { fakeFs, pnpapiResolution });
};

let hook;
var builtLoader = () => {
  if (typeof hook === `undefined`)
    hook = require$$0__default.default.brotliDecompressSync(Buffer.from("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", "base64")).toString();
  return hook;
};

exports.LinkType = LinkType;
exports.generateInlinedScript = generateInlinedScript;
exports.generateLoader = generateLoader;
exports.generatePrettyJson = generatePrettyJson;
exports.generateSplitScript = generateSplitScript;
exports.getESMLoaderTemplate = builtLoader;
exports.hydratePnpFile = hydratePnpFile;
exports.hydratePnpSource = hydratePnpSource;
exports.makeRuntimeApi = makeRuntimeApi;
