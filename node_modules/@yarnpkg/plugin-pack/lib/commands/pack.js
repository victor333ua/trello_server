"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const cli_1 = require("@yarnpkg/cli");
const core_1 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const clipanion_1 = require("clipanion");
const packUtils = tslib_1.__importStar(require("../packUtils"));
// eslint-disable-next-line arca/no-default-export
class PackCommand extends cli_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.installIfNeeded = clipanion_1.Option.Boolean(`--install-if-needed`, false, {
            description: `Run a preliminary \`yarn install\` if the package contains build scripts`,
        });
        this.dryRun = clipanion_1.Option.Boolean(`-n,--dry-run`, false, {
            description: `Print the file paths without actually generating the package archive`,
        });
        this.json = clipanion_1.Option.Boolean(`--json`, false, {
            description: `Format the output as an NDJSON stream`,
        });
        this.out = clipanion_1.Option.String(`-o,--out`, {
            description: `Create the archive at the specified path`,
        });
        // Legacy option
        this.filename = clipanion_1.Option.String(`--filename`, { hidden: true });
    }
    async execute() {
        var _a;
        const configuration = await core_1.Configuration.find(this.context.cwd, this.context.plugins);
        const { project, workspace } = await core_1.Project.find(configuration, this.context.cwd);
        if (!workspace)
            throw new cli_1.WorkspaceRequiredError(project.cwd, this.context.cwd);
        if (await packUtils.hasPackScripts(workspace)) {
            if (this.installIfNeeded) {
                await project.install({
                    cache: await core_1.Cache.find(configuration),
                    report: new core_1.ThrowReport(),
                });
            }
            else {
                await project.restoreInstallState();
            }
        }
        const out = (_a = this.out) !== null && _a !== void 0 ? _a : this.filename;
        const target = typeof out !== `undefined`
            ? fslib_1.ppath.resolve(this.context.cwd, interpolateOutputName(out, { workspace }))
            : fslib_1.ppath.resolve(workspace.cwd, `package.tgz`);
        const report = await core_1.StreamReport.start({
            configuration,
            stdout: this.context.stdout,
            json: this.json,
        }, async (report) => {
            await packUtils.prepareForPack(workspace, { report }, async () => {
                report.reportJson({ base: fslib_1.npath.fromPortablePath(workspace.cwd) });
                const files = await packUtils.genPackList(workspace);
                for (const file of files) {
                    report.reportInfo(null, fslib_1.npath.fromPortablePath(file));
                    report.reportJson({ location: fslib_1.npath.fromPortablePath(file) });
                }
                if (!this.dryRun) {
                    const pack = await packUtils.genPackStream(workspace, files);
                    const write = fslib_1.xfs.createWriteStream(target);
                    pack.pipe(write);
                    await new Promise(resolve => {
                        write.on(`finish`, resolve);
                    });
                }
            });
            if (!this.dryRun) {
                report.reportInfo(core_1.MessageName.UNNAMED, `Package archive generated in ${core_1.formatUtils.pretty(configuration, target, core_1.formatUtils.Type.PATH)}`);
                report.reportJson({ output: fslib_1.npath.fromPortablePath(target) });
            }
        });
        return report.exitCode();
    }
}
PackCommand.paths = [
    [`pack`],
];
PackCommand.usage = clipanion_1.Command.Usage({
    description: `generate a tarball from the active workspace`,
    details: `
      This command will turn the active workspace into a compressed archive suitable for publishing. The archive will by default be stored at the root of the workspace (\`package.tgz\`).

      If the \`-o,---out\` is set the archive will be created at the specified path. The \`%s\` and \`%v\` variables can be used within the path and will be respectively replaced by the package name and version.
    `,
    examples: [[
            `Create an archive from the active workspace`,
            `yarn pack`,
        ], [
            `List the files that would be made part of the workspace's archive`,
            `yarn pack --dry-run`,
        ], [
            `Name and output the archive in a dedicated folder`,
            `yarn pack --out /artifacts/%s-%v.tgz`,
        ]],
});
exports.default = PackCommand;
function interpolateOutputName(name, { workspace }) {
    const interpolated = name
        .replace(`%s`, prettyWorkspaceIdent(workspace))
        .replace(`%v`, prettyWorkspaceVersion(workspace));
    return fslib_1.npath.toPortablePath(interpolated);
}
function prettyWorkspaceIdent(workspace) {
    if (workspace.manifest.name !== null) {
        return core_1.structUtils.slugifyIdent(workspace.manifest.name);
    }
    else {
        return `package`;
    }
}
function prettyWorkspaceVersion(workspace) {
    if (workspace.manifest.version !== null) {
        return workspace.manifest.version;
    }
    else {
        return `unknown`;
    }
}
