"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.packUtils = exports.PackCommand = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@yarnpkg/core");
const core_2 = require("@yarnpkg/core");
const pack_1 = tslib_1.__importDefault(require("./commands/pack"));
exports.PackCommand = pack_1.default;
const packUtils = tslib_1.__importStar(require("./packUtils"));
exports.packUtils = packUtils;
const DEPENDENCY_TYPES = [`dependencies`, `devDependencies`, `peerDependencies`];
const WORKSPACE_PROTOCOL = `workspace:`;
const beforeWorkspacePacking = (workspace, rawManifest) => {
    var _a, _b;
    if (rawManifest.publishConfig) {
        if (rawManifest.publishConfig.type)
            rawManifest.type = rawManifest.publishConfig.type;
        if (rawManifest.publishConfig.main)
            rawManifest.main = rawManifest.publishConfig.main;
        if (rawManifest.publishConfig.browser)
            rawManifest.browser = rawManifest.publishConfig.browser;
        if (rawManifest.publishConfig.module)
            rawManifest.module = rawManifest.publishConfig.module;
        if (rawManifest.publishConfig.exports)
            rawManifest.exports = rawManifest.publishConfig.exports;
        if (rawManifest.publishConfig.bin) {
            rawManifest.bin = rawManifest.publishConfig.bin;
        }
    }
    const project = workspace.project;
    for (const dependencyType of DEPENDENCY_TYPES) {
        for (const descriptor of workspace.manifest.getForScope(dependencyType).values()) {
            const matchingWorkspace = project.tryWorkspaceByDescriptor(descriptor);
            const range = core_1.structUtils.parseRange(descriptor.range);
            if (range.protocol !== WORKSPACE_PROTOCOL)
                continue;
            if (matchingWorkspace === null) {
                if (project.tryWorkspaceByIdent(descriptor) === null) {
                    throw new core_2.ReportError(core_2.MessageName.WORKSPACE_NOT_FOUND, `${core_1.structUtils.prettyDescriptor(project.configuration, descriptor)}: No local workspace found for this range`);
                }
            }
            else {
                let versionToWrite;
                // For workspace:path/to/workspace and workspace:* we look up the workspace version
                if (core_1.structUtils.areDescriptorsEqual(descriptor, matchingWorkspace.anchoredDescriptor) || range.selector === `*`)
                    versionToWrite = (_a = matchingWorkspace.manifest.version) !== null && _a !== void 0 ? _a : `0.0.0`;
                // For workspace:~ and workspace:^ we add the selector in front of the workspace version
                else if (range.selector === `~` || range.selector === `^`)
                    versionToWrite = `${range.selector}${(_b = matchingWorkspace.manifest.version) !== null && _b !== void 0 ? _b : `0.0.0`}`;
                else
                    // for workspace:version we simply strip the protocol
                    versionToWrite = range.selector;
                // Ensure optional dependencies are handled as well
                const identDescriptor = dependencyType === `dependencies`
                    ? core_1.structUtils.makeDescriptor(descriptor, `unknown`)
                    : null;
                const finalDependencyType = identDescriptor !== null && workspace.manifest.ensureDependencyMeta(identDescriptor).optional
                    ? `optionalDependencies`
                    : dependencyType;
                rawManifest[finalDependencyType][core_1.structUtils.stringifyIdent(descriptor)] = versionToWrite;
            }
        }
    }
};
const plugin = {
    hooks: {
        beforeWorkspacePacking,
    },
    commands: [
        pack_1.default,
    ],
};
// eslint-disable-next-line arca/no-default-export
exports.default = plugin;
